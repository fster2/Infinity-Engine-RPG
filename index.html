<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#212121">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    <title>Virtue Seekers - Infinity Engine</title>
    
    <!-- Modern Font Stack -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono&display=swap" rel="stylesheet">
    
    <style>
        /* ================================
           ENHANCED DARK MODE DESIGN SYSTEM
           ================================ */
        :root {
            /* Enhanced Dark Theme Colors */
            --bg-primary: #0a0a0a;
            --bg-secondary: #141414;
            --bg-tertiary: #1f1f1f;
            --bg-chat: #0f0f0f;
            --bg-elevated: #252525;
            
            /* Text with better contrast */
            --text-primary: #f5f5f5;
            --text-secondary: #b8b8b8;
            --text-tertiary: #808080;
            
            /* Vibrant Accent */
            --accent-primary: #00d4aa;
            --accent-hover: #00a884;
            --accent-glow: rgba(0, 212, 170, 0.3);
            
            /* Status Colors */
            --accent-danger: #ff4757;
            --accent-warning: #ffa502;
            --accent-success: #00d4aa;
            
            /* Message Bubbles */
            --user-bg: #1a1a1a;
            --assistant-bg: #0f0f0f;
            
            /* Enhanced Borders */
            --border-primary: #2a2a2a;
            --border-secondary: #1f1f1f;
            --border-accent: rgba(0, 212, 170, 0.3);
            
            /* Rich Shadows */
            --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.3);
            --shadow-md: 0 8px 16px rgba(0, 0, 0, 0.4);
            --shadow-lg: 0 16px 32px rgba(0, 0, 0, 0.5);
            --shadow-glow: 0 0 20px var(--accent-glow);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background: var(--bg-primary);
            color: var(--text-primary);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            font-size: 14px;
            line-height: 1.6;
            min-height: 100vh;
            overflow: hidden;
            position: relative;
        }
        
        /* Subtle background pattern */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                radial-gradient(circle at 20% 50%, var(--accent-glow) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(0, 212, 170, 0.1) 0%, transparent 50%);
            pointer-events: none;
            opacity: 0.3;
        }

        /* Main Layout */
        #app {
            display: flex;
            flex-direction: column;
            height: 100vh;
            position: relative;
            z-index: 1;
        }

        /* Enhanced Header */
        .app-header {
            background: rgba(20, 20, 20, 0.8);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--border-accent);
            padding: 16px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
            box-shadow: var(--shadow-md);
            position: relative;
            z-index: 10;
        }

        .app-title {
            font-size: 18px;
            font-weight: 700;
            color: var(--text-primary);
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .app-title::before {
            content: '⚔️';
            font-size: 24px;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .save-indicator {
            font-size: 12px;
            color: var(--text-tertiary);
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background: var(--bg-tertiary);
            border-radius: 20px;
            transition: all 0.3s ease;
        }
        
        .save-indicator.saving {
            color: var(--accent-primary);
            box-shadow: var(--shadow-glow);
        }

        .save-dot {
            width: 8px;
            height: 8px;
            background: var(--accent-primary);
            border-radius: 50%;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .save-dot.active {
            opacity: 1;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { 
                opacity: 0.4; 
                transform: scale(1);
            }
            50% { 
                opacity: 1; 
                transform: scale(1.2);
            }
        }

        .menu-button {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            color: var(--text-secondary);
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .menu-button:hover {
            background: var(--accent-primary);
            color: var(--bg-primary);
            border-color: var(--accent-primary);
            transform: translateY(-1px);
            box-shadow: var(--shadow-glow);
        }
        
        .menu-button::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }
        
        .menu-button:active::after {
            width: 300px;
            height: 300px;
        }

        /* Enhanced Chat Container */
        .chat-container {
            flex: 1;
            overflow-y: auto;
            background: var(--bg-chat);
            position: relative;
        }
        
        /* Custom scrollbar */
        .chat-container::-webkit-scrollbar {
            width: 8px;
        }
        
        .chat-container::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }
        
        .chat-container::-webkit-scrollbar-thumb {
            background: var(--border-primary);
            border-radius: 4px;
        }
        
        .chat-container::-webkit-scrollbar-thumb:hover {
            background: var(--accent-primary);
        }

        .chat-messages {
            max-width: 900px;
            margin: 0 auto;
            padding: 32px 0;
        }

        /* Enhanced Message Styles */
        .message {
            padding: 24px 48px;
            border-bottom: 1px solid var(--border-secondary);
            animation: slideIn 0.4s ease-out;
            position: relative;
            transition: background 0.3s ease;
        }
        
        @keyframes slideIn {
            from { 
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.user {
            background: var(--user-bg);
        }
        
        .message.user:hover {
            background: rgba(26, 26, 26, 0.8);
        }

        .message.assistant {
            background: var(--assistant-bg);
        }
        
        .message.assistant:hover {
            background: rgba(15, 15, 15, 0.8);
        }

        .message-header {
            display: flex;
            align-items: center;
            gap: 14px;
            margin-bottom: 16px;
        }

        .message-avatar {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 16px;
            box-shadow: var(--shadow-sm);
            position: relative;
        }
        
        .message-avatar::after {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 10px;
            padding: 2px;
            background: linear-gradient(45deg, var(--accent-primary), var(--accent-hover));
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .message:hover .message-avatar::after {
            opacity: 1;
        }

        .user .message-avatar {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .assistant .message-avatar {
            background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-hover) 100%);
            color: white;
        }

        .message-role {
            font-weight: 600;
            font-size: 15px;
            color: var(--text-primary);
        }

        .message-content {
            margin-left: 50px;
            color: var(--text-primary);
        }

        /* Enhanced Narrative Sections */
        .narrative-section {
            margin: 20px 0;
            position: relative;
            padding-left: 24px;
            border-left: 3px solid transparent;
            transition: all 0.3s ease;
        }
        
        .narrative-section::before {
            content: '';
            position: absolute;
            left: -3px;
            top: 0;
            bottom: 0;
            width: 3px;
            background: linear-gradient(to bottom, var(--accent-primary), transparent);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .narrative-section:hover::before {
            opacity: 1;
        }
        
        .narrative-section:hover {
            background: linear-gradient(to right, rgba(0, 212, 170, 0.05), transparent);
            padding-left: 28px;
        }

        .section-label {
            font-size: 11px;
            font-weight: 700;
            color: var(--accent-primary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .section-label::before {
            content: '';
            width: 20px;
            height: 2px;
            background: var(--accent-primary);
            border-radius: 2px;
        }

        .section-content {
            text-align: left;
            line-height: 1.8;
            color: var(--text-secondary);
        }

        .section-content p {
            margin-bottom: 16px;
            text-align: justify;
        }

        .section-content p:last-child {
            margin-bottom: 0;
        }

        /* Enhanced Dialogue Boxes */
        .dialogue-container {
            margin: 20px 0;
            display: grid;
            gap: 12px;
        }

        .dialogue-box {
            background: var(--bg-elevated);
            border: 1px solid var(--border-primary);
            border-radius: 12px;
            padding: 16px 20px;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .dialogue-box::before {
            content: '"';
            position: absolute;
            top: -10px;
            left: 10px;
            font-size: 60px;
            color: var(--accent-primary);
            opacity: 0.1;
            font-family: 'Georgia', serif;
        }

        .dialogue-box:hover {
            border-color: var(--accent-primary);
            transform: translateX(4px);
            box-shadow: -4px 0 20px rgba(0, 212, 170, 0.2);
        }

        .dialogue-speaker {
            font-weight: 700;
            color: var(--accent-primary);
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 6px;
        }

        .dialogue-tone {
            font-size: 12px;
            color: var(--text-tertiary);
            font-style: italic;
            margin-bottom: 8px;
            opacity: 0.8;
        }

        .dialogue-text {
            color: var(--text-primary);
            line-height: 1.6;
        }

        /* Enhanced Choice Cards */
        .choices-grid {
            display: grid;
            gap: 12px;
            margin: 24px 0;
        }

        .choice-card {
            background: var(--bg-elevated);
            border: 2px solid var(--border-primary);
            border-radius: 12px;
            padding: 16px 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 16px;
            position: relative;
            overflow: hidden;
        }
        
        .choice-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(0, 212, 170, 0.1), transparent);
            transform: translateX(-100%);
            transition: transform 0.6s ease;
        }

        .choice-card:hover {
            background: var(--bg-tertiary);
            border-color: var(--accent-primary);
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(0, 212, 170, 0.2);
        }
        
        .choice-card:hover::before {
            transform: translateX(100%);
        }

        .choice-number {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-hover));
            color: var(--bg-primary);
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 14px;
            flex-shrink: 0;
            box-shadow: var(--shadow-sm);
        }

        .choice-text {
            flex: 1;
            color: var(--text-primary);
            font-size: 15px;
            line-height: 1.5;
        }

        /* Enhanced Input Area */
        .input-container {
            background: linear-gradient(to top, rgba(20, 20, 20, 0.9), transparent);
            backdrop-filter: blur(20px);
            border-top: 1px solid var(--border-accent);
            padding: 20px;
            flex-shrink: 0;
            box-shadow: 0 -10px 30px rgba(0, 0, 0, 0.4);
        }

        .input-wrapper {
            max-width: 900px;
            margin: 0 auto;
            display: flex;
            gap: 12px;
            align-items: flex-end;
        }

        .custom-input {
            flex: 1;
            background: var(--bg-elevated);
            border: 2px solid var(--border-primary);
            border-radius: 12px;
            padding: 14px 18px;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 15px;
            resize: none;
            min-height: 48px;
            max-height: 200px;
            line-height: 1.5;
            transition: all 0.3s ease;
        }

        .custom-input:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px var(--accent-glow);
        }
        
        .custom-input::placeholder {
            color: var(--text-tertiary);
        }

        .send-button {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-hover));
            color: white;
            border: none;
            border-radius: 12px;
            padding: 12px 24px;
            font-weight: 600;
            font-size: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            position: relative;
            overflow: hidden;
            box-shadow: var(--shadow-sm);
        }

        .send-button:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md), var(--shadow-glow);
        }
        
        .send-button:active {
            transform: translateY(0);
        }

        .send-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Enhanced Character Creation */
        .creation-form {
            background: var(--bg-elevated);
            border: 1px solid var(--border-primary);
            border-radius: 16px;
            padding: 32px;
            margin: 20px 0;
            box-shadow: var(--shadow-md);
        }
        
        .creation-form h2 {
            margin-bottom: 8px;
            color: var(--accent-primary);
        }

        .form-grid {
            display: grid;
            gap: 20px;
            margin-top: 24px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .form-label {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .form-input {
            background: var(--bg-secondary);
            border: 2px solid var(--border-primary);
            border-radius: 8px;
            padding: 12px 16px;
            color: var(--text-primary);
            font-size: 15px;
            transition: all 0.3s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--accent-primary);
            background: var(--bg-tertiary);
        }

        .form-textarea {
            min-height: 100px;
            resize: vertical;
            font-family: inherit;
        }

        .optional-tag {
            font-size: 11px;
            color: var(--text-tertiary);
            font-weight: normal;
            font-style: italic;
        }

        /* Enhanced Class Selection */
        .class-grid {
            display: grid;
            gap: 16px;
            margin: 24px 0;
        }

        .class-option {
            background: var(--bg-elevated);
            border: 2px solid transparent;
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .class-option::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: radial-gradient(circle, var(--accent-glow) 0%, transparent 70%);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .class-option:hover {
            border-color: var(--accent-primary);
            background: var(--bg-tertiary);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }
        
        .class-option:hover::after {
            width: 300px;
            height: 300px;
        }

        .class-option.selected {
            border-color: var(--accent-primary);
            background: var(--bg-tertiary);
            box-shadow: 0 0 0 3px var(--accent-glow);
        }

        .class-name {
            font-weight: 700;
            font-size: 18px;
            margin-bottom: 8px;
            color: var(--accent-primary);
        }

        .class-description {
            color: var(--text-secondary);
            font-size: 14px;
            line-height: 1.6;
        }

        /* Enhanced Menu Modal */
        .menu-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .menu-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border-accent);
            border-radius: 16px;
            padding: 32px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: var(--shadow-lg);
            animation: menuSlideIn 0.3s ease-out;
        }
        
        @keyframes menuSlideIn {
            from {
                opacity: 0;
                transform: scale(0.95) translateY(20px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .menu-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 28px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-primary);
        }

        .menu-title {
            font-size: 24px;
            font-weight: 700;
            color: var(--accent-primary);
            letter-spacing: 0.5px;
        }

        .close-button {
            background: transparent;
            border: none;
            color: var(--text-tertiary);
            font-size: 28px;
            cursor: pointer;
            padding: 0;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .close-button:hover {
            color: var(--accent-danger);
            background: rgba(255, 71, 87, 0.1);
            transform: rotate(90deg);
        }

        .menu-section {
            margin-bottom: 32px;
        }

        .menu-section-title {
            font-size: 12px;
            font-weight: 700;
            color: var(--text-tertiary);
            margin-bottom: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .menu-section-title::after {
            content: '';
            flex: 1;
            height: 1px;
            background: var(--border-primary);
        }

        .menu-button-grid {
            display: grid;
            gap: 12px;
        }

        .menu-action {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 10px;
            padding: 16px 20px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
            font-size: 15px;
            position: relative;
            overflow: hidden;
        }
        
        .menu-action::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, var(--accent-glow), transparent);
            transition: left 0.6s ease;
        }

        .menu-action:hover {
            background: var(--bg-elevated);
            border-color: var(--accent-primary);
            padding-left: 28px;
            color: var(--accent-primary);
        }
        
        .menu-action:hover::before {
            left: 100%;
        }

        /* Enhanced Character Sheet */
        .character-sheet {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 16px;
            padding: 24px;
            box-shadow: var(--shadow-sm);
        }

        .character-stat-grid {
            display: grid;
            gap: 20px;
        }

        .stat-group {
            border-bottom: 1px solid var(--border-primary);
            padding-bottom: 20px;
            position: relative;
            padding-right: 40px;
        }

        .stat-group:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }

        .stat-label {
            font-size: 12px;
            font-weight: 700;
            color: var(--accent-primary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        .stat-value {
            color: var(--text-primary);
            font-size: 15px;
            line-height: 1.6;
        }

        .stat-list {
            list-style: none;
            padding: 0;
            margin-top: 8px;
        }

        .stat-list li {
            padding: 6px 0;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .stat-list li::before {
            content: '▸';
            color: var(--accent-primary);
        }

        /* Enhanced Loading */
        .loading {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }

        .spinner {
            width: 24px;
            height: 24px;
            border: 3px solid var(--border-primary);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Enhanced Regenerate Button */
        .regenerate-button {
            background: transparent;
            border: 1px solid var(--border-primary);
            color: var(--text-tertiary);
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            margin-top: 16px;
        }

        .regenerate-button:hover {
            background: var(--bg-tertiary);
            color: var(--accent-primary);
            border-color: var(--accent-primary);
            transform: translateY(-1px);
        }

        /* Remove Buttons for Trackers */
        .stat-group .close-button {
            position: absolute;
            right: 0;
            top: 0;
            width: 28px;
            height: 28px;
            font-size: 18px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            color: var(--text-tertiary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            transition: all 0.3s ease;
        }
        
        .stat-group .close-button:hover {
            background: var(--accent-danger);
            border-color: var(--accent-danger);
            color: white;
            transform: scale(1.1);
        }
        
        /* Enhanced Edit Functionality */
        .edit-button {
            background: transparent;
            border: 1px solid var(--border-primary);
            color: var(--text-tertiary);
            padding: 6px 14px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            margin-left: auto;
            transition: all 0.3s ease;
            font-weight: 500;
        }
        
        .edit-button:hover {
            background: var(--bg-tertiary);
            color: var(--accent-primary);
            border-color: var(--accent-primary);
        }
        
        .edit-textarea {
            width: 100%;
            background: var(--bg-elevated);
            border: 2px solid var(--accent-primary);
            border-radius: 8px;
            padding: 14px;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 15px;
            line-height: 1.6;
            resize: vertical;
            min-height: 100px;
        }
        
        .edit-buttons {
            display: flex;
            gap: 10px;
            margin-top: 12px;
        }
        
        .save-edit-button {
            background: var(--accent-primary);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 8px 20px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .save-edit-button:hover {
            background: var(--accent-hover);
            transform: translateY(-1px);
        }
        
        .cancel-edit-button {
            background: transparent;
            border: 1px solid var(--border-primary);
            color: var(--text-secondary);
            border-radius: 8px;
            padding: 8px 20px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .cancel-edit-button:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border-color: var(--accent-danger);
        }
        
        /* Enhanced Memory Palace Visualization */
        #memory-palace-container {
            position: fixed;
            inset: 0;
            background: var(--bg-primary);
            z-index: 2000;
            display: none;
        }
        
        #memory-palace-canvas {
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, var(--bg-secondary), var(--bg-primary));
        }
        
        .palace-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(20, 20, 20, 0.9);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-accent);
            border-radius: 16px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            box-shadow: var(--shadow-lg);
        }
        
        .palace-button {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 10px;
            padding: 12px 20px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            font-weight: 500;
        }
        
        .palace-button:hover {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
            transform: translateX(4px);
        }
        
        .palace-button.active {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
            box-shadow: var(--shadow-glow);
        }
        
        .palace-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(20, 20, 20, 0.9);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-accent);
            border-radius: 16px;
            padding: 20px;
            max-width: 350px;
            box-shadow: var(--shadow-lg);
        }
        
        .palace-tooltip {
            position: absolute;
            background: var(--bg-elevated);
            border: 1px solid var(--accent-primary);
            border-radius: 10px;
            padding: 14px;
            pointer-events: none;
            z-index: 2100;
            font-size: 13px;
            max-width: 280px;
            box-shadow: var(--shadow-lg);
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.3s, transform 0.3s;
        }
        
        .palace-tooltip.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        .node-label {
            font-size: 12px;
            fill: var(--text-primary);
            text-anchor: middle;
            pointer-events: none;
            font-weight: 500;
        }
        
        .link-label {
            font-size: 10px;
            fill: var(--text-tertiary);
            text-anchor: middle;
        }
        
        /* Enhanced Utility Classes */
        .hidden {
            display: none !important;
        }
        
        .fade-in {
            animation: fadeIn 0.5s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* Mobile Optimizations */
        @media (max-width: 768px) {
            body {
                font-size: 13px;
            }
            
            .app-header {
                padding: 12px 16px;
            }
            
            .app-title {
                font-size: 16px;
            }
            
            .message {
                padding: 20px 24px;
            }
            
            .menu-content {
                width: 95%;
                padding: 24px;
            }
            
            .palace-controls {
                top: 10px;
                left: 10px;
                padding: 16px;
            }
            
            .palace-button {
                font-size: 13px;
                padding: 10px 16px;
            }
            
            .custom-input {
                font-size: 14px;
            }
            
            .choice-card {
                padding: 14px 16px;
            }
            
            .input-container {
                padding: 16px;
            }
        }
        
        /* Touch optimizations for Galaxy S23 FE */
        @media (hover: none) and (pointer: coarse) {
            .menu-button:active {
                background: var(--accent-primary);
                color: var(--bg-primary);
            }
            
            .choice-card:active {
                background: var(--bg-tertiary);
                border-color: var(--accent-primary);
            }
            
            .menu-action:active {
                background: var(--bg-elevated);
                border-color: var(--accent-primary);
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- Header -->
        <header class="app-header">
            <div class="app-title">Virtue Seekers</div>
            <div class="header-controls">
                <div class="save-indicator" id="save-indicator-container">
                    <div class="save-dot" id="save-indicator"></div>
                    <span id="save-text">Saved</span>
                </div>
                <button class="menu-button" onclick="window.appCall('showMenu')">Menu</button>
            </div>
        </header>

        <!-- Chat Container -->
        <div class="chat-container" id="chat-container">
            <div class="chat-messages" id="chat-messages">
                <!-- Messages will be inserted here -->
            </div>
        </div>

        <!-- Input Area -->
        <div class="input-container">
            <div class="input-wrapper">
                <textarea 
                    id="custom-input" 
                    class="custom-input" 
                    placeholder="What do you do? (or press 1-4 for choices)"
                    rows="1"></textarea>
                <button id="send-button" class="send-button" onclick="window.app && window.app.sendAction()">Send</button>
            </div>
        </div>

        <!-- Menu Modal (hidden by default) -->
        <div id="menu-modal" class="menu-modal hidden">
            <div class="menu-content">
                <div class="menu-header">
                    <h2 class="menu-title">Menu</h2>
                    <button class="close-button" onclick="window.appCall('hideMenu')">×</button>
                </div>
                
                <div class="menu-section">
                    <h3 class="menu-section-title">Character</h3>
                    <div class="menu-button-grid">
                        <button class="menu-action" onclick="window.appCall('showCharacterSheet')">View Character Sheet</button>
                        <button class="menu-action" onclick="window.appCall('showPartyMembers')">Party Members</button>
                        <button class="menu-action" onclick="window.appCall('showQuestJournal')">Quest Journal</button>
                        <button class="menu-action" onclick="window.appCall('showRelationships')">Relationship Tracker</button>
                        <button class="menu-action" onclick="window.appCall('showMemoryPalace')">Memory Palace</button>
                    </div>
                </div>
                
                <div class="menu-section">
                    <h3 class="menu-section-title">Story</h3>
                    <div class="menu-button-grid">
                        <button class="menu-action" onclick="window.appCall('showSearchInterface')">Search Narratives</button>
                        <button class="menu-action" onclick="window.appCall('exportStory')">Export Story</button>
                        <button class="menu-action" onclick="window.appCall('showStats')">Story Statistics</button>
                    </div>
                </div>
                
                <div class="menu-section">
                    <h3 class="menu-section-title">System</h3>
                    <div class="menu-button-grid">
                        <button class="menu-action" onclick="window.appCall('changeApiKey')">Change API Key</button>
                        <button class="menu-action" onclick="window.appCall('clearData')">Start New Story</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Memory Palace Visualization Container -->
    <div id="memory-palace-container">
        <div class="palace-controls">
            <button class="palace-button active" onclick="window.appCall('setPalaceView', 'timeline', this)">Timeline</button>
            <button class="palace-button" onclick="window.appCall('setPalaceView', 'relationships', this)">Relationships</button>
            <button class="palace-button" onclick="window.appCall('setPalaceView', 'locations', this)">Locations</button>
            <button class="palace-button" onclick="window.appCall('setPalaceView', 'heatmap', this)">Memory Heat</button>
            <button class="menu-action" onclick="window.appCall('hideMemoryPalace')" style="margin-top: 12px;">Close Palace</button>
        </div>
        
        <svg id="memory-palace-canvas"></svg>
        
        <div class="palace-info" id="palace-info">
            <h3 style="margin-bottom: 8px;">Memory Palace</h3>
            <p style="font-size: 13px; color: var(--text-secondary);">
                Navigate your story's shape. Click nodes to explore memories.
            </p>
        </div>
        
        <div class="palace-tooltip" id="palace-tooltip"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script>
        // CRITICAL: Define global functions BEFORE app initialization
        // This ensures they're available as soon as the page loads
        
        // Primary app call wrapper with robust error handling
        window.appCall = function(methodName, ...args) {
            console.log(`[AppCall] Attempting to call: ${methodName}`, args);
            
            // If app exists and method exists, call it
            if (window.app && typeof window.app[methodName] === 'function') {
                try {
                    return window.app[methodName](...args);
                } catch (error) {
                    console.error(`[AppCall] Error in ${methodName}:`, error);
                    alert(`An error occurred. Please try again or refresh the page.`);
                }
            } else {
                // App not ready - retry with delay
                console.warn(`[AppCall] App not ready, retrying ${methodName}...`);
                
                // Show loading feedback for menu
                if (methodName === 'showMenu') {
                    alert('Please wait for the app to finish loading...');
                }
                
                // Retry after delay
                setTimeout(() => {
                    if (window.app && typeof window.app[methodName] === 'function') {
                        try {
                            window.app[methodName](...args);
                        } catch (error) {
                            console.error(`[AppCall] Retry failed for ${methodName}:`, error);
                        }
                    }
                }, 500);
            }
        };
        
        // Ensure showMenu is always available as a direct function
        window.showMenu = function() {
            console.log('[ShowMenu] Direct call to showMenu');
            window.appCall('showMenu');
        };
        
        // Safety check on DOMContentLoaded
        document.addEventListener('DOMContentLoaded', function() {
            console.log('[Init] DOM Content Loaded - Checking functions...');
            
            // Verify critical functions exist
            const requiredFunctions = ['appCall', 'showMenu'];
            requiredFunctions.forEach(fn => {
                if (typeof window[fn] !== 'function') {
                    console.error(`[Init] Missing required function: ${fn}`);
                    // Create emergency stub
                    window[fn] = function() {
                        alert('App is still initializing. Please wait a moment and try again.');
                    };
                }
            });
            
            // Update menu button state when app is ready
            const checkAppReady = setInterval(() => {
                if (window.app && window.app.showMenu) {
                    console.log('[Init] App is ready!');
                    const menuButton = document.querySelector('.menu-button');
                    if (menuButton) {
                        menuButton.style.opacity = '1';
                        menuButton.style.cursor = 'pointer';
                    }
                    clearInterval(checkAppReady);
                }
            }, 100);
        });
    </script>
// ============================================
// VIRTUE SEEKERS INFINITY ENGINE - COMPLETE
// ============================================

class VirtueSeekers {
    constructor() {
        // Core properties
        this.apiKey = null;
        this.currentStory = null;
        this.messageHistory = [];
        this.isProcessing = false;
        this.partyMembers = [];
        this.questJournal = [];
        this.relationships = {};
        this.npcPersonalities = {};
        this.contextMemory = {
            recentEvents: [],
            worldFacts: {},
            locationMemory: {},
            itemMemory: {},
            activeThreads: [],
            compressedHistory: []
        };
        
        // Performance optimization
        this.cacheQueue = new Set();
        this.preloadCache = new Map();
        this.compressionCache = new Map();
        this.embeddingCache = new Map();
        
        // Search index
        this.searchIndex = {
            scenes: [],
            embeddings: new Map()
        };
        
        // Prediction engine
        this.choicePredictions = {
            patterns: {},
            history: []
        };
        
        // Error recovery
        this.fallbackQueue = [];
        this.retryAttempts = 0;
        this.maxRetries = 3;
        
        // Auto quest system
        this.questTemplates = null;
        this.lastQuestGeneration = 0;
        
        // Storage
        this.STORAGE_PREFIX = 'virtue_seekers_';
        this.STORAGE_KEYS = {
            API_KEY: 'api_key',
            CURRENT_STORY: 'current_story',
            MESSAGE_HISTORY: 'message_history',
            PARTY_MEMBERS: 'party_members',
            WORLD_STATE: 'world_state',
            QUEST_JOURNAL: 'quest_journal',
            RELATIONSHIPS: 'relationships',
            NPC_PERSONALITIES: 'npc_personalities',
            CONTEXT_MEMORY: 'context_memory',
            SEARCH_INDEX: 'search_index'
        };
        
        // Auto-save timer
        this.autoSaveInterval = null;
        
        // Last choices for keyboard shortcuts
        this.lastChoices = [];
        
        // Visual elements
        this.palaceVisualization = null;
        
        // Web Worker for background processing
        this.worker = null;
        
        // Wait for DOM to be ready before initializing
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => this.initialize());
        } else {
            // DOM is already ready
            this.initialize();
        }
    }
    
    async initialize() {
        try {
            // Ensure DOM elements exist
            if (!document.getElementById('chat-messages')) {
                console.error('Required DOM elements not found');
                return;
            }
            
            // Setup handlers first
            this.setupInputHandlers();
            this.setupKeyboardShortcuts();
            
            // Load saved data
            const savedApiKey = this.getFromStorage(this.STORAGE_KEYS.API_KEY);
            const savedStory = this.getFromStorage(this.STORAGE_KEYS.CURRENT_STORY);
            const savedHistory = this.getFromStorage(this.STORAGE_KEYS.MESSAGE_HISTORY);
            
            if (savedApiKey) {
                this.apiKey = savedApiKey;
                
                if (savedStory && savedHistory && savedHistory.length > 0) {
                    // Resume existing story
                    this.currentStory = savedStory;
                    this.messageHistory = savedHistory;
                    this.partyMembers = this.getFromStorage(this.STORAGE_KEYS.PARTY_MEMBERS) || [];
                    this.questJournal = this.getFromStorage(this.STORAGE_KEYS.QUEST_JOURNAL) || [];
                    this.relationships = this.getFromStorage(this.STORAGE_KEYS.RELATIONSHIPS) || {};
                    this.npcPersonalities = this.getFromStorage(this.STORAGE_KEYS.NPC_PERSONALITIES) || {};
                    this.contextMemory = this.getFromStorage(this.STORAGE_KEYS.CONTEXT_MEMORY) || this.contextMemory;
                    
                    // Rebuild search index
                    const savedIndex = this.getFromStorage(this.STORAGE_KEYS.SEARCH_INDEX);
                    if (savedIndex) {
                        this.searchIndex.scenes = savedIndex;
                    }
                    
                    this.displayMessageHistory();
                    this.addMessage('system', '✨ Welcome back! Your adventure continues...');
                } else {
                    // New story
                    await this.startNewStory();
                }
                
                // Start auto-save
                this.startAutoSave();
            } else {
                // First time - show API key prompt
                this.showApiKeyPrompt();
            }
            
            // Initialize background worker
            this.initializeWebWorker();
            
        } catch (error) {
            console.error('Initialization error:', error);
            // Still try to show API key prompt as fallback
            try {
                this.showApiKeyPrompt();
            } catch (e) {
                console.error('Critical initialization failure:', e);
                alert('Failed to initialize the app. Please refresh the page.');
            }
        }
    }
    
    // ============================================
    // UI SETUP
    // ============================================
    
    setupInputHandlers() {
        const input = document.getElementById('custom-input');
        if (!input) {
            console.warn('Custom input not found');
            return;
        }
        
        // Auto-resize textarea
        input.addEventListener('input', () => {
            input.style.height = 'auto';
            input.style.height = input.scrollHeight + 'px';
        });
        
        // Handle Enter (send) vs Shift+Enter (new line)
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                this.sendAction();
            }
        });
    }
    
    setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
            // Escape to show menu
            if (e.key === 'Escape') {
                this.toggleMenu();
            }
            
            // Number keys for choices
            if (!this.isProcessing && e.key >= '1' && e.key <= '5') {
                const choices = document.querySelectorAll('.choice-card');
                const index = parseInt(e.key) - 1;
                if (choices[index]) {
                    choices[index].click();
                }
            }
        });
    }
    
    // ============================================
    // STORAGE WITH ERROR HANDLING
    // ============================================
    
    saveToStorage(key, value) {
        try {
            const serialized = JSON.stringify(value);
            // Check size
            if (serialized.length > 5000000) { // 5MB limit
                console.warn(`Storage warning: ${key} is ${(serialized.length / 1000000).toFixed(2)}MB`);
            }
            localStorage.setItem(this.STORAGE_PREFIX + key, serialized);
            this.showSaveIndicator();
        } catch (e) {
            console.error('Storage failed:', e);
            if (e.name === 'QuotaExceededError') {
                this.handleStorageQuotaExceeded();
            }
        }
    }
    
    getFromStorage(key) {
        try {
            const item = localStorage.getItem(this.STORAGE_PREFIX + key);
            return item ? JSON.parse(item) : null;
        } catch (e) {
            console.error('Storage read failed:', e);
            return null;
        }
    }
    
    handleStorageQuotaExceeded() {
        // Compress old data
        if (this.messageHistory.length > 100) {
            // Keep only last 100 messages
            this.messageHistory = this.messageHistory.slice(-100);
            this.saveToStorage(this.STORAGE_KEYS.MESSAGE_HISTORY, this.messageHistory);
        }
        
        // Clear search index
        this.searchIndex = { scenes: [], embeddings: new Map() };
        this.saveToStorage(this.STORAGE_KEYS.SEARCH_INDEX, []);
        
        this.addMessage('system', '⚠️ Storage space low. Compressed older data to continue.');
    }
    
    showSaveIndicator() {
        const container = document.getElementById('save-indicator-container');
        const dot = document.getElementById('save-indicator');
        const text = document.getElementById('save-text');
        
        container.classList.add('saving');
        dot.classList.add('active');
        text.textContent = 'Saving...';
        
        setTimeout(() => {
            container.classList.remove('saving');
            dot.classList.remove('active');
            text.textContent = 'Saved';
        }, 1000);
    }
    
    startAutoSave() {
        this.autoSaveInterval = setInterval(() => {
            if (this.messageHistory.length > 0 && !this.isProcessing) {
                this.saveToStorage(this.STORAGE_KEYS.MESSAGE_HISTORY, this.messageHistory);
                this.saveToStorage(this.STORAGE_KEYS.CURRENT_STORY, this.currentStory);
                this.saveToStorage(this.STORAGE_KEYS.PARTY_MEMBERS, this.partyMembers);
                this.saveToStorage(this.STORAGE_KEYS.QUEST_JOURNAL, this.questJournal);
                this.saveToStorage(this.STORAGE_KEYS.RELATIONSHIPS, this.relationships);
                this.saveToStorage(this.STORAGE_KEYS.NPC_PERSONALITIES, this.npcPersonalities);
                this.saveToStorage(this.STORAGE_KEYS.CONTEXT_MEMORY, this.contextMemory);
            }
        }, 30000); // Every 30 seconds
    }
    
    // ============================================
    // API KEY MANAGEMENT
    // ============================================
    
    showApiKeyPrompt() {
        this.addMessage('system', `
            <div class="creation-form">
                <h2 style="margin-bottom: 16px;">Welcome to Virtue Seekers</h2>
                <p style="margin-bottom: 20px; color: var(--text-secondary);">
                    To begin your infinite narrative journey, please enter your OpenAI API key.
                    Your key is stored locally and never shared.
                </p>
                <div class="form-group">
                    <label class="form-label">OpenAI API Key</label>
                    <input type="password" id="api-key-input" class="form-input" placeholder="sk-...">
                </div>
                <div style="margin-top: 16px;">
                    <button class="send-button" onclick="window.appCall('submitApiKey')">Begin Adventure</button>
                </div>
                <p style="margin-top: 16px; font-size: 12px; color: var(--text-tertiary);">
                    Need a key? <a href="https://platform.openai.com/api-keys" target="_blank" style="color: var(--accent-primary);">Get one from OpenAI →</a>
                </p>
            </div>
        `);
        
        // Focus the input
        setTimeout(() => {
            const input = document.getElementById('api-key-input');
            if (input) input.focus();
        }, 100);
    }
    
    async submitApiKey() {
        const input = document.getElementById('api-key-input');
        const apiKey = input.value.trim();
        
        if (!apiKey || !apiKey.startsWith('sk-')) {
            alert('Please enter a valid OpenAI API key');
            return;
        }
        
        // Test the API key
        try {
            const testResponse = await fetch('https://api.openai.com/v1/models', {
                headers: { 'Authorization': `Bearer ${apiKey}` }
            });
            
            if (!testResponse.ok) {
                throw new Error('Invalid API key');
            }
        } catch (error) {
            alert('Invalid API key. Please check and try again.');
            return;
        }
        
        this.apiKey = apiKey;
        this.saveToStorage(this.STORAGE_KEYS.API_KEY, apiKey);
        this.clearChat();
        await this.startNewStory();
    }
    
    // ============================================
    // CHARACTER CREATION
    // ============================================
    
    async startNewStory() {
        this.currentStory = {
            id: Date.now(),
            character: null,
            sceneCount: 0,
            created: new Date().toISOString()
        };
        
        this.addMessage('assistant', `
            <h2 style="margin-bottom: 16px;">Create Your Character</h2>
            <p style="margin-bottom: 20px;">Tell me about your character. Fill in what you'd like - the rest will be generated procedurally.</p>
            
            <div class="creation-form" id="character-form">
                <div class="form-grid">
                    <div class="form-group">
                        <label class="form-label">Name <span class="optional-tag">(required)</span></label>
                        <input type="text" id="char-name" class="form-input" placeholder="Enter character name">
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Gender <span class="optional-tag">(optional)</span></label>
                        <input type="text" id="char-gender" class="form-input" placeholder="Any gender or leave blank">
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Appearance <span class="optional-tag">(optional)</span></label>
                        <textarea id="char-appearance" class="form-input form-textarea" placeholder="Describe how your character looks"></textarea>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Personality <span class="optional-tag">(optional)</span></label>
                        <textarea id="char-personality" class="form-input form-textarea" placeholder="Describe their personality traits"></textarea>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Alignment <span class="optional-tag">(optional)</span></label>
                        <input type="text" id="char-alignment" class="form-input" placeholder="e.g., Chaotic Good, True Neutral">
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">What They Love <span class="optional-tag">(optional)</span></label>
                        <input type="text" id="char-loves" class="form-input" placeholder="What brings them joy?">
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">What They Hate <span class="optional-tag">(optional)</span></label>
                        <input type="text" id="char-hates" class="form-input" placeholder="What do they despise?">
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Background <span class="optional-tag">(optional)</span></label>
                        <textarea id="char-background" class="form-input form-textarea" placeholder="Any backstory details?"></textarea>
                    </div>
                </div>
                
                <div style="margin-top: 20px;">
                    <button class="send-button" onclick="window.appCall('proceedToClassSelection')">Continue →</button>
                </div>
            </div>
        `);
        
        // Focus name field
        setTimeout(() => document.getElementById('char-name')?.focus(), 100);
    }
    
    async proceedToClassSelection() {
        const name = document.getElementById('char-name').value.trim();
        if (!name) {
            alert('Please enter a character name');
            return;
        }
        
        // Collect all character data
        const characterData = {
            name: name,
            gender: document.getElementById('char-gender').value.trim() || 'unspecified',
            appearance: document.getElementById('char-appearance').value.trim() || 'mysterious',
            personality: document.getElementById('char-personality').value.trim() || 'determined',
            alignment: document.getElementById('char-alignment').value.trim() || 'neutral',
            loves: document.getElementById('char-loves').value.trim() || 'adventure',
            hates: document.getElementById('char-hates').value.trim() || 'injustice',
            background: document.getElementById('char-background').value.trim() || 'unknown'
        };
        
        // Store character data temporarily
        this.currentStory.character = characterData;
        
        // Generate classes
        this.isProcessing = true;
        this.addMessage('system', '<div class="loading"><span class="spinner"></span>Discovering unique paths...</div>');
        
        const classes = await this.generateClasses(characterData);
        
        // Remove loading message
        this.removeLastMessage();
        
        this.addMessage('assistant', `
            <h2 style="margin-bottom: 16px;">Choose Your Path</h2>
            <p style="margin-bottom: 20px;">Select a class for ${name}:</p>
            
            <div class="class-grid" id="class-selection">
                ${classes.map((cls, i) => `
                    <div class="class-option" data-index="${i}" onclick="window.appCall('selectClass', ${i})">
                        <div class="class-name">${cls.name}</div>
                        <div class="class-description">${cls.description}</div>
                    </div>
                `).join('')}
            </div>
            
            <button class="regenerate-button" onclick="window.appCall('regenerateClasses')">
                ↻ Show Different Classes
            </button>
        `);
        
        // Store classes for selection
        this.generatedClasses = classes;
        this.isProcessing = false;
    }
    
    async selectClass(index) {
        const selectedClass = this.generatedClasses[index];
        this.currentStory.character.class = selectedClass.name;
        this.currentStory.character.classDescription = selectedClass.description;
        
        // Save character
        this.saveToStorage(this.STORAGE_KEYS.CURRENT_STORY, this.currentStory);
        
        // Show user's selection
        this.addMessage('user', `I choose to be a ${selectedClass.name}.`);
        
        // Generate opening scene
        await this.generateOpeningScene();
    }
    
    async regenerateClasses() {
        if (this.isProcessing) return;
        
        this.isProcessing = true;
        this.addMessage('system', '<div class="loading"><span class="spinner"></span>Discovering new paths...</div>');
        
        const classes = await this.generateClasses(this.currentStory.character);
        
        this.removeLastMessage();
        
        // Update the class selection
        const classGrid = document.getElementById('class-selection');
        if (classGrid) {
            classGrid.innerHTML = classes.map((cls, i) => `
                <div class="class-option" data-index="${i}" onclick="window.appCall('selectClass', ${i})">
                    <div class="class-name">${cls.name}</div>
                    <div class="class-description">${cls.description}</div>
                </div>
            `).join('');
        }
        
        this.generatedClasses = classes;
        this.isProcessing = false;
    }
    
    // ============================================
    // NARRATIVE GENERATION
    // ============================================
    
    async generateClasses(characterData) {
        try {
            const response = await this.callGPT([
                {
                    role: 'system',
                    content: `Generate 6 unique fantasy RPG classes tailored to this character: ${JSON.stringify(characterData)}. Each should be creative and unusual, not standard fantasy tropes. Return as JSON array with "name" and "description" fields. Keep descriptions to one compelling sentence.`
                },
                {
                    role: 'user',
                    content: 'Generate 6 unique character classes. Be creative and avoid clichés.'
                }
            ], 0.9, 400);
            
            const jsonMatch = response.match(/\[[\s\S]*\]/);
            if (jsonMatch) {
                return JSON.parse(jsonMatch[0]);
            }
        } catch (error) {
            console.error('Class generation failed:', error);
        }
        
        // Fallback classes
        return [
            { name: "Dreamwright", description: "Architects who build reality from the fragments of sleeping minds" },
            { name: "Voidbinder", description: "Those who forge contracts with the hungry spaces between stars" },
            { name: "Thornkeeper", description: "Guardians who cultivate gardens of living memory and painful beauty" },
            { name: "Echowalker", description: "Wanderers who step through the reverberations of past and future" },
            { name: "Glassweaver", description: "Artisans who spin fate itself from threads of crystallized time" },
            { name: "Shadowscribe", description: "Writers whose words cast living darkness across reality" }
        ];
    }
    
    async generateOpeningScene() {
        this.isProcessing = true;
        this.addMessage('system', '<div class="loading"><span class="spinner"></span>Weaving your story...</div>');
        
        const response = await this.generateNarrativeWithRetry(
            `Begin the adventure. ${this.currentStory.character.name} the ${this.currentStory.character.class} awakens in a mysterious location. Create a compelling opening scene.`,
            true
        );
        
        this.removeLastMessage();
        
        if (response) {
            await this.displayNarrativeResponse(response);
            this.currentStory.sceneCount++;
            this.saveToStorage(this.STORAGE_KEYS.CURRENT_STORY, this.currentStory);
            
            // Start auto-save
            if (!this.autoSaveInterval) {
                this.startAutoSave();
            }
        }
        
        this.isProcessing = false;
    }
    
    async handleChoice(choiceText) {
        if (this.isProcessing) return;
        
        this.addMessage('user', choiceText);
        
        this.isProcessing = true;
        this.addMessage('system', '<div class="loading"><span class="spinner"></span>Continuing the narrative...</div>');
        
        const response = await this.generateNarrativeWithRetry(
            `The player chose: "${choiceText}"`,
            false
        );
        
        this.removeLastMessage();
        
        if (response) {
            await this.displayNarrativeResponse(response);
            this.currentStory.sceneCount++;
            
            // Track choice for predictions
            this.trackChoicePattern(choiceText);
            
            // Check for auto-quest generation
            await this.checkAutoQuestGeneration();
        }
        
        this.isProcessing = false;
    }
    
    async sendAction() {
        const input = document.getElementById('custom-input');
        const action = input.value.trim();
        
        if (!action || this.isProcessing) return;
        
        // Clear input
        input.value = '';
        input.style.height = 'auto';
        
        // Check if this is a choice selection
        const choiceMatch = action.match(/^(\d)$/);
        if (choiceMatch) {
            const choiceNum = parseInt(choiceMatch[1]);
            const choices = this.lastChoices;
            if (choices && choices[choiceNum - 1]) {
                await this.handleChoice(choices[choiceNum - 1]);
                return;
            }
        }
        
        // Custom action
        this.addMessage('user', action);
        
        this.isProcessing = true;
        this.addMessage('system', '<div class="loading"><span class="spinner"></span>Weaving your action into the story...</div>');
        
        const response = await this.generateNarrativeWithRetry(
            `I attempt to: ${action}`,
            false
        );
        
        this.removeLastMessage();
        
        if (response) {
            await this.displayNarrativeResponse(response);
            
            // Index for search
            await this.indexScene(response, action);
        }
        
        this.isProcessing = false;
    }
    
    async generateNarrativeWithRetry(userInput, isOpening = false) {
        let attempts = 0;
        
        while (attempts < this.maxRetries) {
            try {
                const context = await this.buildEnhancedContext();
                const systemPrompt = this.buildSystemPrompt(isOpening);
                
                const messages = [
                    { role: 'system', content: systemPrompt + '\n\nContext:\n' + context },
                    { role: 'user', content: userInput }
                ];
                
                const response = await this.callGPT(messages, 0.8, 1000);
                
                // Validate response
                if (this.validateNarrativeResponse(response)) {
                    return response;
                } else {
                    throw new Error('Invalid response format');
                }
                
            } catch (error) {
                attempts++;
                console.error(`Narrative generation attempt ${attempts} failed:`, error);
                
                if (attempts >= this.maxRetries) {
                    this.addMessage('system', `⚠️ Generation failed after ${this.maxRetries} attempts. ${error.message}`);
                    return null;
                }
                
                // Wait before retry
                await new Promise(resolve => setTimeout(resolve, 1000 * attempts));
            }
        }
        
        return null;
    }
    
    buildSystemPrompt(isOpening) {
        const char = this.currentStory.character;
        
        return `You are a Fantasy RPG Game Master creating a Virtue Seekers narrative.
Your role is to craft immersive, purely fantasy narratives with magical, mysterious environments.

CRITICAL: Generate 500-700 words per scene. Rich, detailed prose is REQUIRED.

Character Details:
- Name: ${char.name}
- Class: ${char.class} (${char.classDescription})
- Gender: ${char.gender}
- Appearance: ${char.appearance}
- Personality: ${char.personality}
- Alignment: ${char.alignment}
- Loves: ${char.loves}
- Hates: ${char.hates}
- Background: ${char.background}

${Object.keys(this.npcPersonalities).length > 0 ? `
ACTIVE NPC PERSONALITIES (MUST maintain these traits):
${Object.entries(this.npcPersonalities).slice(0, 5).map(([name, p]) => 
    `${name}: ${p.personality}, speaks ${p.speechPattern}, ${p.emotionalState} mood`
).join('\n')}` : ''}

STRUCTURE YOUR RESPONSE EXACTLY AS FOLLOWS:

[Environmental Description]
Write 2-3 detailed paragraphs describing the setting. Include:
- Visual details: colors, lighting, shadows, movement
- Sensory information: sounds, smells, temperature, textures
- Magical elements: glowing runes, floating objects, mystical phenomena
- Atmospheric mood: tension, wonder, mystery, danger

[Character Positions and Actions]
1 detailed paragraph showing:
- Exact positions of all characters
- What each character is doing
- Body language and expressions
- Any equipment or magical effects

[Character Dialogue]
Format EXACTLY as: Name: (tone/emotion) "Dialogue."
- Each NPC must reflect their established personality
- Show emotion through word choice and speech patterns
- Include 3-5 exchanges minimum
- Natural interruptions and reactions

[Choice Presentation]
Provide 2-5 meaningful choices:
1. [Action]: [Compelling description of what happens]
2. [Action]: [Different approach with consequences]
3. [Action]: [Creative or unexpected option]
(Number choices based on situation complexity)

[Scene-Closing Hook]
1 paragraph that:
- Builds tension or mystery
- Hints at consequences
- Creates anticipation for what comes next
- Ends with sensory detail or dramatic moment`;
    }
    
    validateNarrativeResponse(response) {
        // Check for required sections
        const requiredSections = [
            'Environmental Description',
            'Character Positions',
            'Dialogue',
            'Choice Presentation',
            'Scene-Closing Hook'
        ];
        
        for (const section of requiredSections) {
            if (!response.includes(`[${section}`) && !response.includes(`[Character Dialogue]`)) {
                console.warn(`Missing section: ${section}`);
                return false;
            }
        }
        
        // Check minimum length (500 words)
        if (response.split(' ').length < 400) {
            console.warn('Response too short');
            return false;
        }
        
        return true;
    }
    
    async displayNarrativeResponse(response) {
        const sections = this.parseNarrativeResponse(response);
        
        let html = '<div class="narrative-content fade-in">';
        
        // Environmental Description
        if (sections.environmental) {
            html += `
                <div class="narrative-section">
                    <div class="section-label">Environmental Description</div>
                    <div class="section-content">${this.formatParagraphs(sections.environmental)}</div>
                </div>
            `;
        }
        
        // Character Positioning
        if (sections.positioning) {
            html += `
                <div class="narrative-section">
                    <div class="section-label">Character Positioning</div>
                    <div class="section-content">${this.formatParagraphs(sections.positioning)}</div>
                </div>
            `;
        }
        
        // Dialogue
        if (sections.dialogue && sections.dialogue.length > 0) {
            html += `
                <div class="narrative-section">
                    <div class="section-label">Dialogue</div>
                    <div class="dialogue-container">
            `;
            
            for (const line of sections.dialogue) {
                html += `
                    <div class="dialogue-box">
                        <div class="dialogue-speaker">${line.speaker}</div>
                        <div class="dialogue-tone">(${line.tone})</div>
                        <div class="dialogue-text">${line.text}</div>
                    </div>
                `;
                
                // Auto-track NPCs with personality generation
                await this.trackNPCFromDialogue(line.speaker, line.tone);
            }
            
            html += '</div></div>';
        }
        
        // Available Actions
        if (sections.actions && sections.actions.length > 0) {
            html += `
                <div class="narrative-section">
                    <div class="section-label">Available Actions</div>
                    <div class="choices-grid">
            `;
            
            sections.actions.forEach((action, i) => {
                html += `
                    <div class="choice-card" onclick="window.appCall('handleChoice', '${this.escapeQuotes(action)}')">
                        <div class="choice-number">${i + 1}</div>
                        <div class="choice-text">${action}</div>
                    </div>
                `;
            });
            
            html += '</div></div>';
            
            // Store choices for keyboard shortcuts
            this.lastChoices = sections.actions;
        }
        
        // Scene Hook
        if (sections.hook) {
            html += `
                <div class="narrative-section">
                    <div class="section-label">Scene Hook</div>
                    <div class="section-content" style="font-style: italic;">${this.formatParagraphs(sections.hook)}</div>
                </div>
            `;
        }
        
        html += `
            <button class="regenerate-button" onclick="window.appCall('regenerateScene')">
                ↻ Regenerate Scene
            </button>
        </div>`;
        
        this.addMessage('assistant', html);
        
        // Update AI memory system with new scene data
        await this.updateContextMemory(response);
        
        // Auto-detect quests
        this.detectAndAddQuests(response);
    }
    
    parseNarrativeResponse(text) {
        const sections = {
            environmental: '',
            positioning: '',
            dialogue: [],
            actions: [],
            hook: ''
        };
        
        // Enhanced parser for better section detection
        const sectionRegex = /\[([^\]]+)\]/g;
        const parts = text.split(sectionRegex);
        
        let currentSection = '';
        
        for (let i = 0; i < parts.length; i++) {
            const part = parts[i].trim();
            
            if (part.match(/Environmental Description/i)) {
                currentSection = 'environmental';
            } else if (part.match(/Character Position/i)) {
                currentSection = 'positioning';
            } else if (part.match(/Character Dialogue|Dialogue/i)) {
                currentSection = 'dialogue';
            } else if (part.match(/Choice Presentation|Available Actions/i)) {
                currentSection = 'actions';
            } else if (part.match(/Scene[\-\s]*Closing Hook|Hook/i)) {
                currentSection = 'hook';
            } else if (currentSection && part) {
                switch (currentSection) {
                    case 'environmental':
                        sections.environmental = part;
                        break;
                    case 'positioning':
                        sections.positioning = part;
                        break;
                    case 'dialogue':
                        // Enhanced dialogue parsing
                        const lines = part.split('\n').filter(line => line.trim());
                        lines.forEach(line => {
                            // Multiple regex patterns for flexibility
                            const patterns = [
                                /^([^:]+):\s*\(([^)]+)\)\s*"([^"]+)"/,
                                /^([^:]+):\s*\(([^)]+)\)\s*(.+)$/,
                                /^([^:]+):\s*"([^"]+)"/
                            ];
                            
                            for (const pattern of patterns) {
                                const match = line.match(pattern);
                                if (match) {
                                    if (match.length === 4) {
                                        sections.dialogue.push({
                                            speaker: match[1].trim(),
                                            tone: match[2].trim(),
                                            text: match[3].trim()
                                        });
                                    } else if (match.length === 3) {
                                        sections.dialogue.push({
                                            speaker: match[1].trim(),
                                            tone: 'neutral',
                                            text: match[2].trim()
                                        });
                                    }
                                    break;
                                }
                            }
                        });
                        break;
                    case 'actions':
                        // Parse numbered actions
                        const actionLines = part.split('\n');
                        actionLines.forEach(line => {
                            const actionMatch = line.match(/^\d+\.\s*(.+)$/);
                            if (actionMatch) {
                                sections.actions.push(actionMatch[1].trim());
                            }
                        });
                        break;
                    case 'hook':
                        sections.hook = part;
                        break;
                }
            }
        }
        
        return sections;
    }
    
    formatParagraphs(text) {
        return text.split('\n\n')
            .map(para => para.trim())
            .filter(para => para)
            .map(para => `<p>${para}</p>`)
            .join('');
    }
    
    escapeQuotes(str) {
        return str.replace(/'/g, "\\'").replace(/"/g, '\\"');
    }
    
    async regenerateScene() {
        if (this.isProcessing) return;
        
        // Find the last narrative message
        const lastNarrative = [...this.messageHistory].reverse().find(msg => 
            msg.role === 'assistant' && msg.content.includes('narrative-content')
        );
        
        if (!lastNarrative) return;
        
        // Remove it
        const index = this.messageHistory.indexOf(lastNarrative);
        this.messageHistory.splice(index, 1);
        this.displayMessageHistory();
        
        // Regenerate with higher temperature
        this.isProcessing = true;
        this.addMessage('system', '<div class="loading"><span class="spinner"></span>Reweaving the narrative...</div>');
        
        const context = await this.buildEnhancedContext();
        
        const messages = [
            {
                role: 'system',
                content: `Generate a DIFFERENT version of the current scene. Vary the events, dialogue, and choices significantly.
                
Context: ${context}

Use the same structure but with completely different content.`
            },
            {
                role: 'user',
                content: 'Generate an alternative version of this scene with different events and choices.'
            }
        ];
        
        try {
            const response = await this.callGPT(messages, 0.95, 1000);
            
            this.removeLastMessage();
            await this.displayNarrativeResponse(response);
            
        } catch (error) {
            this.removeLastMessage();
            this.addMessage('system', `Error: ${error.message}`);
        }
        
        this.isProcessing = false;
    }
    
    // ============================================
    // ENHANCED CONTEXT MANAGEMENT
    // ============================================
    
    async buildEnhancedContext() {
        if (!this.currentStory || !this.currentStory.character) return '';
        
        const char = this.currentStory.character;
        let context = `Character: ${char.name} the ${char.class}\n`;
        context += `Traits: ${char.personality}, ${char.alignment}\n`;
        context += `Loves: ${char.loves}, Hates: ${char.hates}\n\n`;
        
        // Add party members
        if (this.partyMembers.length > 0) {
            context += 'Party Members:\n';
            this.partyMembers.forEach(member => {
                context += `- ${member.name} (${member.class}): ${member.status}\n`;
            });
            context += '\n';
        }
        
        // Add active quests
        const activeQuests = this.questJournal.filter(q => q.status === 'Active');
        if (activeQuests.length > 0) {
            context += 'Active Quests:\n';
            activeQuests.slice(0, 3).forEach(quest => {
                context += `- ${quest.title}: ${quest.description}\n`;
            });
            context += '\n';
        }
        
        // Add recent NPCs with personalities
        const recentNPCs = this.getRecentNPCs();
        if (recentNPCs.length > 0) {
            context += 'Recent NPCs:\n';
            recentNPCs.slice(0, 5).forEach(npc => {
                const personality = this.npcPersonalities[npc.toLowerCase()];
                if (personality) {
                    context += `- ${npc}: ${personality.personality}, ${personality.emotionalState} mood\n`;
                }
            });
            context += '\n';
        }
        
        // Add relevant world facts
        const relevantFacts = await this.getRelevantWorldFacts();
        if (relevantFacts.length > 0) {
            context += 'Established Facts:\n';
            relevantFacts.slice(0, 10).forEach(fact => {
                context += `- ${fact.fact}\n`;
            });
            context += '\n';
        }
        
        // Add current location if known
        const currentLocation = this.getCurrentLocation();
        if (currentLocation && this.contextMemory.locationMemory[currentLocation]) {
            const locMem = this.contextMemory.locationMemory[currentLocation];
            context += `Current Location: ${currentLocation} (visited ${locMem.visits} times)\n\n`;
        }
        
        // Add compressed history summary
        if (this.contextMemory.compressedHistory && this.contextMemory.compressedHistory.length > 0) {
            const recentCompression = this.contextMemory.compressedHistory[this.contextMemory.compressedHistory.length - 1];
            context += `Historical Context: ${recentCompression.summary}\n\n`;
        }
        
        // Add recent events (last 3 scenes)
        const recentScenes = this.getRecentSceneSummaries();
        if (recentScenes.length > 0) {
            context += 'Recent Events:\n';
            recentScenes.forEach((scene, i) => {
                context += `${i + 1}. ${scene}\n`;
            });
        }
        
        return context;
    }
    
    getRecentSceneSummaries() {
        const summaries = [];
        const recentMessages = this.messageHistory.slice(-10);
        
        recentMessages.forEach((msg, i) => {
            if (msg.role === 'user' && i + 1 < recentMessages.length) {
                const nextMsg = recentMessages[i + 1];
                if (nextMsg.role === 'assistant' && nextMsg.content.includes('narrative-content')) {
                    const parsed = this.parseNarrativeResponse(nextMsg.content);
                    if (parsed.hook) {
                        summaries.push(`${msg.content} → ${parsed.hook.substring(0, 100)}...`);
                    }
                }
            }
        });
        
        return summaries.slice(-3);
    }
    
    getRecentNPCs() {
        const npcs = new Set();
        const recentMessages = this.messageHistory.slice(-10);
        
        recentMessages.forEach(msg => {
            if (msg.role === 'assistant' && msg.content.includes('dialogue-speaker')) {
                const speakers = msg.content.match(/<div class="dialogue-speaker">([^<]+)<\/div>/g);
                if (speakers) {
                    speakers.forEach(match => {
                        const speaker = match.replace(/<[^>]+>/g, '').trim();
                        if (speaker !== this.currentStory?.character?.name) {
                            npcs.add(speaker);
                        }
                    });
                }
            }
        });
        
        return Array.from(npcs);
    }
    
    async getRelevantWorldFacts() {
        const allFacts = [];
        Object.values(this.contextMemory.worldFacts).forEach(category => {
            allFacts.push(...category);
        });
        
        // Sort by recency and relevance
        return allFacts
            .sort((a, b) => b.scene - a.scene)
            .slice(0, 15);
    }
    
    getCurrentLocation() {
        // Extract from recent narrative
        const lastNarrative = [...this.messageHistory].reverse().find(msg => 
            msg.role === 'assistant' && msg.content.includes('narrative-content')
        );
        
        if (!lastNarrative) return null;
        
        const parsed = this.parseNarrativeResponse(lastNarrative.content);
        const locationMatch = parsed.environmental?.match(/(?:in|at|inside|within)\s+(?:the\s+)?([A-Z][^.!?]*?)(?:\.|,|!|\?)/i);
        
        return locationMatch ? locationMatch[1].trim() : null;
    }
    
    // ============================================
    // AI MEMORY ENHANCEMENT
    // ============================================
    
    async updateContextMemory(narrativeResponse) {
        const parsed = this.parseNarrativeResponse(narrativeResponse);
        
        // Extract and store facts
        await this.extractWorldFacts(parsed);
        
        // Update location memory
        this.updateLocationMemory(parsed.environmental);
        
        // Track active narrative threads
        this.updateActiveThreads(parsed);
        
        // Update recent events
        this.contextMemory.recentEvents.push({
            scene: this.currentStory?.sceneCount || 0,
            summary: parsed.hook || 'Scene occurred',
            timestamp: Date.now()
        });
        
        // Keep only last 20 events
        if (this.contextMemory.recentEvents.length > 20) {
            this.contextMemory.recentEvents = this.contextMemory.recentEvents.slice(-20);
        }
        
        // Compress older events if needed
        if (this.currentStory?.sceneCount % 10 === 0) {
            await this.compressOlderEvents();
        }
        
        this.saveToStorage(this.STORAGE_KEYS.CONTEXT_MEMORY, this.contextMemory);
    }
    
    async extractWorldFacts(parsedScene) {
        // Use AI to extract important facts
        try {
            const factPrompt = `Extract key facts from this scene that should be remembered:
            Setting: ${parsedScene.environmental || ''}
            Events: ${parsedScene.positioning || ''}
            
            Return as JSON array of short, memorable facts. Focus on:
            - Permanent world details
            - Character revelations
            - Important objects or locations
            - Established rules or limitations
            
            Keep each fact under 100 characters.`;
            
            const response = await this.callGPT([
                { role: 'system', content: 'Extract memorable facts as JSON array. Be concise.' },
                { role: 'user', content: factPrompt }
            ], 0.7, 200);
            
            const jsonMatch = response.match(/\[[\s\S]*\]/);
            if (jsonMatch) {
                const facts = JSON.parse(jsonMatch[0]);
                
                facts.forEach(fact => {
                    const category = this.categorizeFact(fact);
                    if (!this.contextMemory.worldFacts[category]) {
                        this.contextMemory.worldFacts[category] = [];
                    }
                    
                    // Avoid duplicates
                    const exists = this.contextMemory.worldFacts[category].some(
                        f => f.fact.toLowerCase() === fact.toLowerCase()
                    );
                    
                    if (!exists) {
                        this.contextMemory.worldFacts[category].push({
                            fact: fact,
                            scene: this.currentStory?.sceneCount || 0,
                            timestamp: Date.now()
                        });
                        
                        // Keep only most recent 20 facts per category
                        if (this.contextMemory.worldFacts[category].length > 20) {
                            this.contextMemory.worldFacts[category] = 
                                this.contextMemory.worldFacts[category].slice(-20);
                        }
                    }
                });
            }
            
        } catch (error) {
            console.error('Fact extraction failed:', error);
        }
    }
    
    categorizeFact(fact) {
        const lowerFact = fact.toLowerCase();
        if (lowerFact.includes('location') || lowerFact.includes('place') || lowerFact.includes('room')) return 'locations';
        if (lowerFact.includes('character') || lowerFact.includes('person') || lowerFact.includes('npc')) return 'characters';
        if (lowerFact.includes('magic') || lowerFact.includes('spell') || lowerFact.includes('power')) return 'magic';
        if (lowerFact.includes('item') || lowerFact.includes('artifact') || lowerFact.includes('weapon')) return 'items';
        if (lowerFact.includes('rule') || lowerFact.includes('law') || lowerFact.includes('tradition')) return 'rules';
        return 'general';
    }
    
    updateLocationMemory(environmental) {
        if (!environmental) return;
        
        // Multiple patterns for location extraction
        const patterns = [
            /(?:in|at|inside|within|entering|approaching)\s+(?:the\s+)?([A-Z][^.!?,]*?)(?:\.|,|!|\?|$)/i,
            /(?:The|This)\s+([A-Z][^.!?,]*?)\s+(?:is|was|seems|appears)/i,
            /^([A-Z][^.!?,]*?)\s+(?:stretches|looms|rises|stands)/i
        ];
        
        for (const pattern of patterns) {
            const match = environmental.match(pattern);
            if (match) {
                const location = match[1].trim();
                if (location.length > 3 && location.length < 50) {
                    if (!this.contextMemory.locationMemory[location]) {
                        this.contextMemory.locationMemory[location] = {
                            firstVisit: this.currentStory?.sceneCount || 0,
                            description: environmental.substring(0, 200),
                            visits: 0
                        };
                    }
                    this.contextMemory.locationMemory[location].visits++;
                    this.contextMemory.locationMemory[location].lastVisit = this.currentStory?.sceneCount || 0;
                    break;
                }
            }
        }
    }
    
    updateActiveThreads(parsed) {
        // Track ongoing narrative threads
        if (parsed.hook) {
            this.contextMemory.activeThreads.push({
                thread: parsed.hook.substring(0, 100),
                startedAt: this.currentStory?.sceneCount || 0,
                status: 'active'
            });
            
            // Keep only last 10 active threads
            if (this.contextMemory.activeThreads.length > 10) {
                this.contextMemory.activeThreads = this.contextMemory.activeThreads.slice(-10);
            }
        }
    }
    
    async compressOlderEvents() {
        // Compress events older than 10 scenes
        const eventsToCompress = this.contextMemory.recentEvents.filter(
            e => (this.currentStory?.sceneCount || 0) - e.scene > 10
        );
        
        if (eventsToCompress.length > 5) {
            try {
                const summary = await this.callGPT([
                    {
                        role: 'system',
                        content: 'Summarize these events into a single paragraph that captures the key story beats. Be concise but preserve critical details.'
                    },
                    {
                        role: 'user',
                        content: `Compress these events: ${eventsToCompress.map(e => e.summary).join('; ')}`
                    }
                ], 0.7, 200);
                
                // Store compressed summary
                this.contextMemory.compressedHistory.push({
                    summary: summary,
                    scenes: eventsToCompress.map(e => e.scene),
                    compressed: Date.now()
                });
                
                // Remove compressed events
                this.contextMemory.recentEvents = this.contextMemory.recentEvents.filter(
                    e => !eventsToCompress.includes(e)
                );
                
                // Keep only last 5 compressions
                if (this.contextMemory.compressedHistory.length > 5) {
                    this.contextMemory.compressedHistory = this.contextMemory.compressedHistory.slice(-5);
                }
                
            } catch (error) {
                console.error('Compression failed:', error);
            }
        }
    }
    
    // ============================================
    // NPC PERSONALITY SYSTEM
    // ============================================
    
    async trackNPCFromDialogue(speaker, tone) {
        const key = speaker.toLowerCase();
        const charName = this.currentStory?.character?.name?.toLowerCase();
        
        // Don't track the player character
        if (key === charName || speaker === 'You' || speaker === 'YOU') return;
        
        // Update or create relationship
        if (!this.relationships[key]) {
            this.addRelationship(speaker);
        } else {
            this.relationships[key].lastInteraction = this.currentStory?.sceneCount || 0;
            this.relationships[key].interactions = (this.relationships[key].interactions || 0) + 1;
        }
        
        // Generate unique personality if not exists
        if (!this.npcPersonalities[key]) {
            await this.generateNPCPersonality(speaker, tone);
        } else {
            // Update emotional state based on recent interaction
            this.npcPersonalities[key].emotionalState = tone;
            this.npcPersonalities[key].interactions++;
        }
    }
    
    async generateNPCPersonality(npcName, initialTone = null) {
        try {
            const response = await this.callGPT([
                {
                    role: 'system',
                    content: `Generate a unique personality profile for an NPC named ${npcName}. Return as JSON with these fields:
                    - personality: 2-3 core traits (e.g., "cunning, ambitious, secretly kind")
                    - speechPattern: how they talk (e.g., "formal with hidden sarcasm")
                    - mannerisms: physical habits (e.g., "taps fingers when thinking")
                    - motivations: what drives them (e.g., "seeks redemption for past mistakes")
                    - secrets: hidden agenda or knowledge (e.g., "knows the location of ancient artifact")
                    - emotionalState: current mood (e.g., "cautiously optimistic")
                    ${initialTone ? `- Their first appearance showed them as: ${initialTone}` : ''}`
                },
                {
                    role: 'user',
                    content: `Create a memorable and complex personality for ${npcName}`
                }
            ], 0.9, 300);
            
            const jsonMatch = response.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                const personality = JSON.parse(jsonMatch[0]);
                
                this.npcPersonalities[npcName.toLowerCase()] = {
                    ...personality,
                    firstAppearance: this.currentStory?.sceneCount || 0,
                    interactions: 1,
                    evolution: []
                };
                
                this.saveToStorage(this.STORAGE_KEYS.NPC_PERSONALITIES, this.npcPersonalities);
            }
            
        } catch (error) {
            console.error('Personality generation failed:', error);
            // Fallback personality
            this.npcPersonalities[npcName.toLowerCase()] = {
                personality: 'mysterious, observant',
                speechPattern: 'measured and careful',
                mannerisms: 'maintains steady eye contact',
                motivations: 'unclear',
                secrets: 'harbors hidden knowledge',
                emotionalState: initialTone || 'guarded',
                firstAppearance: this.currentStory?.sceneCount || 0,
                interactions: 1,
                evolution: []
            };
        }
    }
    
    // ============================================
    // QUEST SYSTEM
    // ============================================
    
    detectAndAddQuests(narrativeResponse) {
        // Look for quest indicators
        const questPatterns = [
            /asks you to ([^.!?]+)/i,
            /needs your help with ([^.!?]+)/i,
            /quest: ([^.!?]+)/i,
            /mission: ([^.!?]+)/i,
            /task: ([^.!?]+)/i,
            /must ([^.!?]+) before/i
        ];
        
        for (const pattern of questPatterns) {
            const match = narrativeResponse.match(pattern);
            if (match) {
                const questDescription = match[1].trim();
                const questTitle = this.generateQuestTitle(questDescription);
                
                // Check if quest already exists
                const exists = this.questJournal.some(q => 
                    q.title.toLowerCase() === questTitle.toLowerCase()
                );
                
                if (!exists) {
                    this.addQuest(questTitle, questDescription);
                    break;
                }
            }
        }
    }
    
    generateQuestTitle(description) {
        // Simple title generation
        const words = description.split(' ').slice(0, 4);
        return words.map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
    }
    
    async checkAutoQuestGeneration() {
        const activeQuests = this.questJournal.filter(q => q.status === 'Active');
        
        // Generate new quest if none active and enough scenes passed
        if (activeQuests.length === 0 && 
            this.currentStory?.sceneCount > this.lastQuestGeneration + 5) {
            
            try {
                const context = await this.buildEnhancedContext();
                const response = await this.callGPT([
                    {
                        role: 'system',
                        content: 'Generate a quest hook based on the current story context. Return as JSON with "title" and "description" fields.'
                    },
                    {
                        role: 'user',
                        content: `Context: ${context}\n\nCreate an engaging quest that fits naturally into the current narrative.`
                    }
                ], 0.8, 150);
                
                const jsonMatch = response.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    const quest = JSON.parse(jsonMatch[0]);
                    this.addQuest(quest.title, quest.description);
                    this.lastQuestGeneration = this.currentStory?.sceneCount || 0;
                }
            } catch (error) {
                console.error('Auto quest generation failed:', error);
            }
        }
    }
    
    addQuest(title, description, objectives = []) {
        const quest = {
            id: Date.now(),
            title,
            description,
            status: 'Active',
            objectives: objectives.map(obj => ({ text: obj, completed: false })),
            addedAt: this.currentStory?.sceneCount || 0,
            completedAt: null
        };
        
        this.questJournal.push(quest);
        this.saveToStorage(this.STORAGE_KEYS.QUEST_JOURNAL, this.questJournal);
        
        // Notify player
        this.addMessage('system', `📜 New Quest: ${title}`);
    }
    
    updateQuest(questId, updates) {
        const questIndex = this.questJournal.findIndex(q => q.id === questId);
        if (questIndex !== -1) {
            this.questJournal[questIndex] = { ...this.questJournal[questIndex], ...updates };
            if (updates.status === 'Completed') {
                this.questJournal[questIndex].completedAt = this.currentStory?.sceneCount || 0;
            }
            this.saveToStorage(this.STORAGE_KEYS.QUEST_JOURNAL, this.questJournal);
        }
    }
    
    removeQuest(index) {
        this.questJournal.splice(index, 1);
        this.saveToStorage(this.STORAGE_KEYS.QUEST_JOURNAL, this.questJournal);
        this.showQuestJournal(); // Refresh the view
    }
    
    // ============================================
    // RELATIONSHIP MANAGEMENT
    // ============================================
    
    addRelationship(character, status = 'Acquaintance', relationship = 'Neutral', notes = '') {
        this.relationships[character.toLowerCase()] = {
            name: character,
            status,
            relationship,
            notes,
            firstMet: this.currentStory?.sceneCount || 0,
            lastInteraction: this.currentStory?.sceneCount || 0,
            interactions: 1
        };
        
        this.saveToStorage(this.STORAGE_KEYS.RELATIONSHIPS, this.relationships);
    }
    
    updateRelationship(character, updates) {
        const key = character.toLowerCase();
        if (this.relationships[key]) {
            this.relationships[key] = { ...this.relationships[key], ...updates };
            this.relationships[key].lastInteraction = this.currentStory?.sceneCount || 0;
            this.saveToStorage(this.STORAGE_KEYS.RELATIONSHIPS, this.relationships);
        } else {
            // Create new relationship if it doesn't exist
            this.addRelationship(character, updates.status, updates.relationship, updates.notes);
        }
    }
    
    removeRelationship(character) {
        delete this.relationships[character.toLowerCase()];
        delete this.npcPersonalities[character.toLowerCase()];
        this.saveToStorage(this.STORAGE_KEYS.RELATIONSHIPS, this.relationships);
        this.saveToStorage(this.STORAGE_KEYS.NPC_PERSONALITIES, this.npcPersonalities);
        this.showRelationships(); // Refresh the view
    }
    
    // ============================================
    // SEARCH FUNCTIONALITY
    // ============================================
    
    async indexScene(sceneContent, userAction = '') {
        const sceneData = {
            scene: this.currentStory?.sceneCount || 0,
            timestamp: Date.now(),
            userAction: userAction,
            content: sceneContent,
            snippet: this.extractSceneSnippet(sceneContent)
        };
        
        this.searchIndex.scenes.push(sceneData);
        
        // Keep only last 100 scenes in search index
        if (this.searchIndex.scenes.length > 100) {
            this.searchIndex.scenes = this.searchIndex.scenes.slice(-100);
        }
        
        this.saveToStorage(this.STORAGE_KEYS.SEARCH_INDEX, this.searchIndex.scenes);
    }
    
    extractSceneSnippet(content) {
        // Extract most interesting part of scene
        const parsed = this.parseNarrativeResponse(content);
        if (parsed.hook) return parsed.hook.substring(0, 200);
        if (parsed.environmental) return parsed.environmental.substring(0, 200);
        return content.substring(0, 200);
    }
    
    async searchNarrative(query) {
        const results = [];
        const queryLower = query.toLowerCase();
        
        // Simple keyword search
        this.searchIndex.scenes.forEach(scene => {
            const contentLower = scene.content.toLowerCase();
            const actionLower = (scene.userAction || '').toLowerCase();
            
            if (contentLower.includes(queryLower) || actionLower.includes(queryLower)) {
                // Calculate relevance score
                const contentMatches = (contentLower.match(new RegExp(queryLower, 'g')) || []).length;
                const actionMatches = (actionLower.match(new RegExp(queryLower, 'g')) || []).length;
                const score = contentMatches + (actionMatches * 2); // Weight user actions higher
                
                results.push({
                    ...scene,
                    score: score
                });
            }
        });
        
        // Sort by relevance and recency
        results.sort((a, b) => {
            if (b.score !== a.score) return b.score - a.score;
            return b.timestamp - a.timestamp;
        });
        
        return results.slice(0, 10); // Top 10 results
    }
    
    // ============================================
    // MESSAGE MANAGEMENT
    // ============================================
    
    addMessage(role, content) {
        const message = {
            id: Date.now(),
            role: role,
            content: content,
            timestamp: new Date().toISOString()
        };
        
        this.messageHistory.push(message);
        this.saveToStorage(this.STORAGE_KEYS.MESSAGE_HISTORY, this.messageHistory);
        
        // Add to UI
        this.appendMessageToUI(message);
        
        // Scroll to bottom
        this.scrollToBottom();
    }
    
    appendMessageToUI(message) {
        const container = document.getElementById('chat-messages');
        if (!container) {
            console.error('Chat messages container not found');
            return;
        }
        
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${message.role}`;
        messageDiv.dataset.messageId = message.id;
        
        if (message.role === 'system') {
            messageDiv.innerHTML = `<div class="message-content">${message.content}</div>`;
        } else {
            const avatar = message.role === 'user' ? 'You' : 'VS';
            const roleLabel = message.role === 'user' ? 'You' : 'Virtue Seekers';
            
            // Add edit button for user messages
            const editButton = message.role === 'user' && !message.content.includes('api-key-input') ? 
                `<button class="edit-button" onclick="window.appCall('editMessage', ${message.id})">Edit</button>` : '';
            
            messageDiv.innerHTML = `
                <div class="message-header">
                    <div class="message-avatar">${avatar}</div>
                    <div class="message-role">${roleLabel}</div>
                    ${editButton}
                </div>
                <div class="message-content" id="content-${message.id}">${message.content}</div>
            `;
        }
        
        container.appendChild(messageDiv);
    }
    
    editMessage(messageId) {
        const messageIndex = this.messageHistory.findIndex(m => m.id === messageId);
        if (messageIndex === -1) return;
        
        const message = this.messageHistory[messageIndex];
        const contentDiv = document.getElementById(`content-${messageId}`);
        
        // Replace content with edit form
        contentDiv.innerHTML = `
            <textarea class="edit-textarea" id="edit-${messageId}">${message.content}</textarea>
            <div class="edit-buttons">
                <button class="save-edit-button" onclick="window.appCall('saveEdit', ${messageId})">Save & Submit</button>
                <button class="cancel-edit-button" onclick="window.appCall('cancelEdit', ${messageId})">Cancel</button>
            </div>
        `;
        
        // Focus and select text
        const textarea = document.getElementById(`edit-${messageId}`);
        textarea.focus();
        textarea.select();
        
        // Auto-resize
        textarea.style.height = 'auto';
        textarea.style.height = textarea.scrollHeight + 'px';
        
        textarea.addEventListener('input', () => {
            textarea.style.height = 'auto';
            textarea.style.height = textarea.scrollHeight + 'px';
        });
    }
    
    async saveEdit(messageId) {
        const messageIndex = this.messageHistory.findIndex(m => m.id === messageId);
        if (messageIndex === -1) return;
        
        const textarea = document.getElementById(`edit-${messageId}`);
        const newContent = textarea.value.trim();
        
        if (!newContent) return;
        
        // Remove all messages after this one
        this.messageHistory = this.messageHistory.slice(0, messageIndex);
        
        // Add the edited message
        this.messageHistory.push({
            id: messageId,
            role: 'user',
            content: newContent,
            timestamp: new Date().toISOString()
        });
        
        // Clear and redisplay up to this point
        this.displayMessageHistory();
        
        // Continue from the edited message
        if (newContent.toLowerCase().includes('i choose')) {
            // It's a choice selection
            await this.handleChoice(newContent);
        } else {
            // It's a custom action
            await this.sendAction();
        }
    }
    
    cancelEdit(messageId) {
        const message = this.messageHistory.find(m => m.id === messageId);
        if (!message) return;
        
        const contentDiv = document.getElementById(`content-${messageId}`);
        contentDiv.innerHTML = message.content;
    }
    
    removeLastMessage() {
        this.messageHistory.pop();
        const messages = document.querySelectorAll('.message');
        if (messages.length > 0) {
            messages[messages.length - 1].remove();
        }
    }
    
    displayMessageHistory() {
        const container = document.getElementById('chat-messages');
        if (!container) {
            console.error('Chat messages container not found');
            return;
        }
        
        container.innerHTML = '';
        
        this.messageHistory.forEach(message => {
            this.appendMessageToUI(message);
        });
        
        this.scrollToBottom();
    }
    
    clearChat() {
        this.messageHistory = [];
        const container = document.getElementById('chat-messages');
        if (container) {
            container.innerHTML = '';
        }
    }
    
    scrollToBottom() {
        const container = document.getElementById('chat-container');
        if (container) {
            setTimeout(() => {
                container.scrollTop = container.scrollHeight;
            }, 100);
        }
    }
    
    // ============================================
    // MENU FUNCTIONS
    // ============================================
    
    showMenu() {
        const modal = document.getElementById('menu-modal');
        if (!modal) {
            console.error('Menu modal not found');
            return;
        }
        modal.classList.remove('hidden');
    }
    
    hideMenu() {
        const modal = document.getElementById('menu-modal');
        if (!modal) {
            console.error('Menu modal not found');
            return;
        }
        modal.classList.add('hidden');
    }
    
    toggleMenu() {
        const menu = document.getElementById('menu-modal');
        if (!menu) {
            console.error('Menu modal not found');
            return;
        }
        menu.classList.toggle('hidden');
    }
    
    restoreMenu() {
        this.hideMenu();
        setTimeout(() => this.showMenu(), 100);
    }
    
    showCharacterSheet() {
        if (!this.currentStory || !this.currentStory.character) {
            alert('No character created yet');
            return;
        }
        
        const char = this.currentStory.character;
        
        const sheetHTML = `
            <div class="character-sheet">
                <h3 style="margin-bottom: 20px; color: var(--accent-primary);">${char.name}'s Character Sheet</h3>
                
                <div class="character-stat-grid">
                    <div class="stat-group">
                        <div class="stat-label">Class</div>
                        <div class="stat-value">${char.class}</div>
                        <div class="stat-value" style="font-size: 13px; color: var(--text-secondary); margin-top: 4px;">
                            ${char.classDescription}
                        </div>
                    </div>
                    
                    <div class="stat-group">
                        <div class="stat-label">Core Traits</div>
                        <div class="stat-value">Gender: ${char.gender}</div>
                        <div class="stat-value">Alignment: ${char.alignment}</div>
                        <div class="stat-value">Personality: ${char.personality}</div>
                    </div>
                    
                    <div class="stat-group">
                        <div class="stat-label">Appearance</div>
                        <div class="stat-value">${char.appearance}</div>
                    </div>
                    
                    <div class="stat-group">
                        <div class="stat-label">Personal Details</div>
                        <div class="stat-value">Loves: ${char.loves}</div>
                        <div class="stat-value">Hates: ${char.hates}</div>
                    </div>
                    
                    <div class="stat-group">
                        <div class="stat-label">Background</div>
                        <div class="stat-value">${char.background}</div>
                    </div>
                    
                    <div class="stat-group">
                        <div class="stat-label">Journey Progress</div>
                        <div class="stat-value">Scenes Completed: ${this.currentStory?.sceneCount || 0}</div>
                        <div class="stat-value">Quests Active: ${this.questJournal.filter(q => q.status === 'Active').length}</div>
                        <div class="stat-value">Relationships: ${Object.keys(this.relationships).length}</div>
                    </div>
                </div>
            </div>
        `;
        
        // Replace menu content temporarily
        const menuContent = document.querySelector('.menu-content');
        
        menuContent.innerHTML = `
            <div class="menu-header">
                <h2 class="menu-title">Character Sheet</h2>
                <button class="close-button" onclick="window.appCall('hideMenu')">×</button>
            </div>
            ${sheetHTML}
            <button class="menu-action" onclick="window.appCall('restoreMenu')" style="margin-top: 20px;">← Back to Menu</button>
        `;
    }
    
    showPartyMembers() {
        const partyHTML = this.partyMembers.length > 0 
            ? this.partyMembers.map((member, index) => `
                <div class="stat-group">
                    <button class="close-button" onclick="window.appCall('removePartyMember', ${index})">×</button>
                    <div class="stat-label">${member.name}</div>
                    <div class="stat-value">Class: ${member.class}</div>
                    <div class="stat-value">Status: ${member.status}</div>
                    ${member.personality ? `<div class="stat-value" style="font-size: 13px; color: var(--text-secondary);">
                        ${member.personality}
                    </div>` : ''}
                </div>
            `).join('')
            : '<p style="color: var(--text-secondary); text-align: center;">No party members yet. You adventure alone.</p>';
            
        const menuContent = document.querySelector('.menu-content');
        menuContent.innerHTML = `
            <div class="menu-header">
                <h2 class="menu-title">Party Members</h2>
                <button class="close-button" onclick="window.appCall('hideMenu')">×</button>
            </div>
            <div class="character-sheet">
                ${partyHTML}
            </div>
            <button class="menu-action" onclick="window.appCall('restoreMenu')" style="margin-top: 20px;">← Back to Menu</button>
        `;
    }
    
    removePartyMember(index) {
        this.partyMembers.splice(index, 1);
        this.saveToStorage(this.STORAGE_KEYS.PARTY_MEMBERS, this.partyMembers);
        this.showPartyMembers();
    }
    
    showQuestJournal() {
        const questHTML = this.questJournal.length > 0 
            ? this.questJournal.map((quest, index) => `
                <div class="stat-group">
                    <button class="close-button" onclick="window.appCall('removeQuest', ${index})">×</button>
                    <div class="stat-label">${quest.title}</div>
                    <div class="stat-value">${quest.description}</div>
                    <div class="stat-value" style="font-size: 12px; color: var(--text-tertiary);">
                        Status: <span style="color: ${quest.status === 'Active' ? 'var(--accent-success)' : 'var(--text-secondary)'}">
                            ${quest.status}
                        </span>
                    </div>
                    ${quest.objectives && quest.objectives.length > 0 ? `
                        <ul class="stat-list">
                            ${quest.objectives.map(obj => `
                                <li>${obj.completed ? '✓' : '○'} ${obj.text}</li>
                            `).join('')}
                        </ul>
                    ` : ''}
                </div>
            `).join('')
            : '<p style="color: var(--text-secondary); text-align: center;">No active quests. Your journey awaits...</p>';
            
        const menuContent = document.querySelector('.menu-content');
        menuContent.innerHTML = `
            <div class="menu-header">
                <h2 class="menu-title">Quest Journal</h2>
                <button class="close-button" onclick="window.appCall('hideMenu')">×</button>
            </div>
            <div class="character-sheet">
                ${questHTML}
            </div>
            <button class="menu-action" onclick="window.appCall('restoreMenu')" style="margin-top: 20px;">← Back to Menu</button>
        `;
    }
    
    showRelationships() {
        const relationshipHTML = Object.keys(this.relationships).length > 0 
            ? Object.entries(this.relationships).map(([character, data]) => {
                const personality = this.npcPersonalities[character.toLowerCase()];
                return `
                    <div class="stat-group">
                        <button class="close-button" onclick="window.appCall('removeRelationship', '${character}')">×</button>
                        <div class="stat-label">${character.toUpperCase()}</div>
                        <div class="stat-value">Status: ${data.status || 'Acquaintance'}</div>
                        <div class="stat-value">Relationship: ${data.relationship || 'Neutral'}</div>
                        ${data.notes ? `<div class="stat-value" style="font-size: 13px; color: var(--text-secondary);">${data.notes}</div>` : ''}
                        ${personality ? `
                            <div class="stat-value" style="font-size: 12px; color: var(--text-tertiary); margin-top: 8px;">
                                Personality: ${personality.personality}<br>
                                Mood: ${personality.emotionalState}
                            </div>
                        ` : ''}
                        <div class="stat-value" style="font-size: 11px; color: var(--text-tertiary);">
                            First met: Scene ${data.firstMet || 0} | Interactions: ${data.interactions || 1}
                        </div>
                    </div>
                `;
            }).join('')
            : '<p style="color: var(--text-secondary); text-align: center;">No relationships tracked yet. Meet some characters!</p>';
            
        const menuContent = document.querySelector('.menu-content');
        menuContent.innerHTML = `
            <div class="menu-header">
                <h2 class="menu-title">Relationship Tracker</h2>
                <button class="close-button" onclick="window.appCall('hideMenu')">×</button>
            </div>
            <div class="character-sheet">
                ${relationshipHTML}
            </div>
            <button class="menu-action" onclick="window.appCall('restoreMenu')" style="margin-top: 20px;">← Back to Menu</button>
        `;
    }
    
    showSearchInterface() {
        const menuContent = document.querySelector('.menu-content');
        menuContent.innerHTML = `
            <div class="menu-header">
                <h2 class="menu-title">Search Narratives</h2>
                <button class="close-button" onclick="window.appCall('hideMenu')">×</button>
            </div>
            
            <div style="margin-bottom: 20px;">
                <input type="text" 
                       id="search-input" 
                       class="form-input" 
                       placeholder="Search for characters, locations, items, or events..."
                       style="width: 100%;">
                <button class="send-button" 
                        onclick="window.appCall('performSearch')" 
                        style="margin-top: 12px; width: 100%;">
                    Search
                </button>
            </div>
            
            <div id="search-results" class="character-sheet">
                <p style="color: var(--text-secondary); text-align: center;">
                    Enter a search term to find scenes from your adventure
                </p>
            </div>
            
            <button class="menu-action" onclick="window.appCall('restoreMenu')" style="margin-top: 20px;">← Back to Menu</button>
        `;
        
        // Focus search input and add enter key support
        const searchInput = document.getElementById('search-input');
        if (searchInput) {
            searchInput.focus();
            searchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') window.appCall('performSearch');
            });
        }
    }
    
    async performSearch() {
        const query = document.getElementById('search-input').value.trim();
        if (!query) return;
        
        const resultsDiv = document.getElementById('search-results');
        resultsDiv.innerHTML = '<div class="loading"><span class="spinner"></span>Searching narratives...</div>';
        
        const results = await this.searchNarrative(query);
        
        if (results.length === 0) {
            resultsDiv.innerHTML = `
                <p style="color: var(--text-secondary); text-align: center;">
                    No results found for "${query}"
                </p>
            `;
        } else {
            resultsDiv.innerHTML = `
                <div class="stat-label" style="margin-bottom: 16px;">
                    Found ${results.length} result${results.length > 1 ? 's' : ''}:
                </div>
                ${results.map(result => `
                    <div class="stat-group">
                        <div class="stat-label">Scene ${result.scene}</div>
                        <div class="stat-value" style="font-size: 12px; color: var(--text-tertiary);">
                            ${new Date(result.timestamp).toLocaleString()}
                        </div>
                        ${result.userAction ? `
                            <div class="stat-value" style="font-weight: 600; margin: 8px 0;">
                                Your action: "${result.userAction}"
                            </div>
                        ` : ''}
                        <div class="stat-value" style="margin-top: 8px; padding: 12px; background: var(--bg-primary); border-radius: 8px; font-style: italic;">
                            ${this.highlightSearchTerm(result.snippet, query)}
                        </div>
                        <button class="menu-action" 
                                onclick="window.appCall('jumpToScene', ${result.scene})" 
                                style="margin-top: 8px; font-size: 12px; padding: 6px 12px;">
                            View Full Scene
                        </button>
                    </div>
                `).join('')}
            `;
        }
    }
    
    highlightSearchTerm(text, term) {
        const regex = new RegExp(`(${term})`, 'gi');
        return text.replace(regex, '<mark style="background: var(--accent-primary); color: var(--bg-primary); padding: 2px 4px; border-radius: 2px;">$1</mark>');
    }
    
    jumpToScene(sceneNumber) {
        // Find the message in history
        const sceneMessage = this.messageHistory.find(msg => {
            if (msg.role === 'assistant' && msg.content.includes('narrative-content')) {
                const parsed = this.parseNarrativeResponse(msg.content);
                const msgIndex = this.messageHistory.indexOf(msg);
                const approxScene = Math.floor(msgIndex / 3);
                return Math.abs(approxScene - sceneNumber) < 2;
            }
            return false;
        });
        
        if (sceneMessage) {
            this.hideMenu();
            const messageElement = document.querySelector(`[data-message-id="${sceneMessage.id}"]`);
            if (messageElement) {
                messageElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                messageElement.style.background = 'var(--accent-primary)';
                messageElement.style.opacity = '0.2';
                setTimeout(() => {
                    messageElement.style.background = '';
                    messageElement.style.opacity = '';
                }, 2000);
            }
        }
    }
    
    async exportStory() {
        const storyData = {
            character: this.currentStory,
            messages: this.messageHistory,
            partyMembers: this.partyMembers,
            questJournal: this.questJournal,
            relationships: this.relationships,
            npcPersonalities: this.npcPersonalities,
            contextMemory: this.contextMemory,
            exportDate: new Date().toISOString()
        };
        
        const blob = new Blob([JSON.stringify(storyData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `virtue-seekers-${this.currentStory?.character?.name || 'story'}-${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
        
        this.hideMenu();
        this.addMessage('system', '✅ Story exported successfully!');
    }
    
    showStats() {
        const stats = {
            scenes: this.currentStory?.sceneCount || 0,
            messages: this.messageHistory.length,
            words: this.messageHistory.reduce((acc, msg) => acc + msg.content.split(' ').length, 0),
            partySize: this.partyMembers.length + 1,
            npcs: Object.keys(this.npcPersonalities).length,
            relationships: Object.keys(this.relationships).length,
            quests: this.questJournal.length,
            questsCompleted: this.questJournal.filter(q => q.status === 'Completed').length,
            locations: Object.keys(this.contextMemory.locationMemory || {}).length,
            facts: Object.values(this.contextMemory.worldFacts || {}).flat().length,
            compressionRatio: this.getCompressionRatio(),
            tokensEstimate: this.estimateTokens(JSON.stringify(this.messageHistory))
        };
        
        const menuContent = document.querySelector('.menu-content');
        menuContent.innerHTML = `
            <div class="menu-header">
                <h2 class="menu-title">Story Statistics</h2>
                <button class="close-button" onclick="window.appCall('hideMenu')">×</button>
            </div>
            <div class="character-sheet">
                <div class="stat-group">
                    <div class="stat-label">Narrative Progress</div>
                    <div class="stat-value">Scenes: ${stats.scenes}</div>
                    <div class="stat-value">Messages: ${stats.messages}</div>
                    <div class="stat-value">Words Written: ${stats.words.toLocaleString()}</div>
                    <div class="stat-value">Estimated Tokens: ${stats.tokensEstimate.toLocaleString()}</div>
                </div>
                <div class="stat-group">
                    <div class="stat-label">World State</div>
                    <div class="stat-value">Active Party: ${stats.partySize} member${stats.partySize > 1 ? 's' : ''}</div>
                    <div class="stat-value">NPCs Met: ${stats.npcs}</div>
                    <div class="stat-value">Relationships: ${stats.relationships}</div>
                    <div class="stat-value">Quests: ${stats.quests} (${stats.questsCompleted} completed)</div>
                </div>
                <div class="stat-group">
                    <div class="stat-label">Memory System</div>
                    <div class="stat-value">Locations Visited: ${stats.locations}</div>
                    <div class="stat-value">World Facts: ${stats.facts}</div>
                    <div class="stat-value">Compression Efficiency: ${stats.compressionRatio}%</div>
                    <div class="stat-value" style="font-size: 12px; color: var(--text-tertiary);">
                        Using advanced AI compression to maintain infinite memory
                    </div>
                </div>
            </div>
            <button class="menu-action" onclick="window.appCall('restoreMenu')" style="margin-top: 20px;">← Back to Menu</button>
        `;
    }
    
    getCompressionRatio() {
        const original = JSON.stringify(this.messageHistory).length;
        const compressed = JSON.stringify(this.contextMemory).length;
        if (original === 0) return 0;
        return Math.round((1 - compressed / original) * 100);
    }
    
    estimateTokens(text) {
        // Rough estimate: 1 token ≈ 4 characters
        return Math.round(text.length / 4);
    }
    
    changeApiKey() {
        if (confirm('Change API key? This will not affect your current story.')) {
            this.hideMenu();
            this.showApiKeyPrompt();
        }
    }
    
    clearData() {
        if (confirm('Start a new story? This will clear all current progress.')) {
            // Clear all data
            this.clearChat();
            this.currentStory = null;
            this.partyMembers = [];
            this.questJournal = [];
            this.relationships = {};
            this.npcPersonalities = {};
            this.contextMemory = {
                recentEvents: [],
                worldFacts: {},
                locationMemory: {},
                itemMemory: {},
                activeThreads: [],
                compressedHistory: []
            };
            this.searchIndex = {
                scenes: [],
                embeddings: new Map()
            };
            
            // Clear storage
            Object.values(this.STORAGE_KEYS).forEach(key => {
                if (key !== this.STORAGE_KEYS.API_KEY) {
                    localStorage.removeItem(this.STORAGE_PREFIX + key);
                }
            });
            
            this.hideMenu();
            this.startNewStory();
        }
    }
    
    // ============================================
    // MEMORY PALACE VISUALIZATION
    // ============================================
    
    showMemoryPalace() {
        this.hideMenu();
        const container = document.getElementById('memory-palace-container');
        container.style.display = 'block';
        
        // Initialize D3 visualization if needed
        if (!this.palaceVisualization) {
            this.initializePalaceVisualization();
        }
        
        // Default to timeline view
        setTimeout(() => {
            this.setPalaceView('timeline');
        }, 100);
    }
    
    hideMemoryPalace() {
        document.getElementById('memory-palace-container').style.display = 'none';
    }
    
    initializePalaceVisualization() {
        // Check if D3 is available
        if (typeof d3 === 'undefined') {
            console.error('D3.js not loaded');
            alert('Visualization library not loaded. Memory Palace unavailable.');
            this.hideMemoryPalace();
            return;
        }
        
        const container = document.getElementById('memory-palace-canvas');
        if (!container) {
            console.error('Memory palace canvas not found');
            return;
        }
        
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        this.palaceVisualization = {
            svg: d3.select('#memory-palace-canvas')
                .attr('width', width)
                .attr('height', height),
            width: width,
            height: height,
            currentView: 'timeline'
        };
        
        // Create base groups
        this.palaceVisualization.defs = this.palaceVisualization.svg.append('defs');
        this.palaceVisualization.linksGroup = this.palaceVisualization.svg.append('g').attr('class', 'links');
        this.palaceVisualization.nodesGroup = this.palaceVisualization.svg.append('g').attr('class', 'nodes');
        this.palaceVisualization.labelsGroup = this.palaceVisualization.svg.append('g').attr('class', 'labels');
        
        // Add zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.1, 10])
            .on('zoom', (event) => {
                this.palaceVisualization.svg.selectAll('g')
                    .attr('transform', event.transform);
            });
            
        this.palaceVisualization.svg.call(zoom);
        
        // Add gradients
        const gradient = this.palaceVisualization.defs.append('linearGradient')
            .attr('id', 'link-gradient')
            .attr('gradientUnits', 'userSpaceOnUse');
            
        gradient.append('stop')
            .attr('offset', '0%')
            .attr('stop-color', '#00d4aa')
            .attr('stop-opacity', 0.2);
            
        gradient.append('stop')
            .attr('offset', '100%')
            .attr('stop-color', '#00d4aa')
            .attr('stop-opacity', 0.8);
    }
    
    setPalaceView(viewType, buttonElement) {
        if (!this.palaceVisualization) {
            console.error('Palace visualization not initialized');
            return;
        }
        
        // Update button states
        document.querySelectorAll('.palace-button').forEach(btn => {
            btn.classList.remove('active');
        });
        
        if (buttonElement) {
            buttonElement.classList.add('active');
        } else {
            document.querySelector(`[onclick*="${viewType}"]`)?.classList.add('active');
        }
        
        this.palaceVisualization.currentView = viewType;
        
        // Clear existing visualization
        if (this.palaceVisualization.linksGroup) {
            this.palaceVisualization.linksGroup.selectAll('*').remove();
        }
        if (this.palaceVisualization.nodesGroup) {
            this.palaceVisualization.nodesGroup.selectAll('*').remove();
        }
        if (this.palaceVisualization.labelsGroup) {
            this.palaceVisualization.labelsGroup.selectAll('*').remove();
        }
        
        // Generate appropriate view
        try {
            switch(viewType) {
                case 'timeline':
                    this.renderTimelineView();
                    break;
                case 'relationships':
                    this.renderRelationshipWeb();
                    break;
                case 'locations':
                    this.renderLocationMap();
                    break;
                case 'heatmap':
                    this.renderMemoryHeatmap();
                    break;
            }
        } catch (error) {
            console.error(`Error rendering ${viewType} view:`, error);
            this.updatePalaceInfo(viewType, 0);
        }
    }
    
    renderTimelineView() {
        if (!this.palaceVisualization || typeof d3 === 'undefined') {
            console.error('Cannot render timeline - visualization not ready');
            return;
        }
        
        const scenes = this.getSceneData();
        const width = this.palaceVisualization.width;
        const height = this.palaceVisualization.height;
        
        if (scenes.length === 0) {
            this.updatePalaceInfo('timeline', 0);
            return;
        }
        
        // Create timeline layout
        const padding = 50;
        const nodeRadius = 8;
        const timeScale = d3.scaleLinear()
            .domain([0, Math.max(scenes.length - 1, 1)])
            .range([padding, width - padding]);
        
        // Simple linear layout for now
        const yPosition = height / 2;
        
        // Draw connections
        const links = [];
        scenes.forEach((scene, i) => {
            if (i > 0) {
                links.push({
                    source: scenes[i - 1],
                    target: scene,
                    strength: 0.5
                });
            }
        });
        
        this.palaceVisualization.linksGroup.selectAll('line')
            .data(links)
            .enter().append('line')
            .attr('x1', d => timeScale(d.source.index))
            .attr('y1', yPosition)
            .attr('x2', d => timeScale(d.target.index))
            .attr('y2', yPosition)
            .attr('stroke', '#00d4aa')
            .attr('stroke-width', 2)
            .attr('stroke-opacity', 0.3);
        
        // Draw nodes
        const nodes = this.palaceVisualization.nodesGroup.selectAll('circle')
            .data(scenes)
            .enter().append('circle')
            .attr('cx', d => timeScale(d.index))
            .attr('cy', yPosition)
            .attr('r', nodeRadius)
            .attr('fill', d => {
                if (d.hasQuest) return '#ffa502';
                if (d.hasCombat) return '#ff4757';
                return '#00d4aa';
            })
            .attr('stroke', '#fff')
            .attr('stroke-width', 2)
            .style('cursor', 'pointer')
            .on('mouseover', (event, d) => this.showPalaceTooltip(event, d))
            .on('mouseout', () => this.hidePalaceTooltip())
            .on('click', (event, d) => this.jumpToMemory(d));
        
        // Add timeline labels
        const labelInterval = Math.ceil(scenes.length / 10);
        this.palaceVisualization.labelsGroup.selectAll('.time-label')
            .data(scenes.filter((s, i) => i % labelInterval === 0))
            .enter().append('text')
            .attr('class', 'node-label')
            .attr('x', d => timeScale(d.index))
            .attr('y', height - 20)
            .attr('text-anchor', 'middle')
            .text(d => `Scene ${d.index + 1}`);
        
        this.updatePalaceInfo('timeline', scenes.length);
    }
    
    renderRelationshipWeb() {
        if (!this.palaceVisualization || typeof d3 === 'undefined') {
            console.error('Cannot render relationships - visualization not ready');
            return;
        }
        
        const relationships = this.getRelationshipData();
        const width = this.palaceVisualization.width;
        const height = this.palaceVisualization.height;
        
        if (relationships.nodes.length === 0) {
            this.updatePalaceInfo('relationships', 0);
            return;
        }
        
        // Create force simulation
        const simulation = d3.forceSimulation(relationships.nodes)
            .force('link', d3.forceLink(relationships.links)
                .id(d => d.id)
                .distance(100))
            .force('charge', d3.forceManyBody().strength(-300))
            .force('center', d3.forceCenter(width / 2, height / 2))
            .force('collision', d3.forceCollide().radius(30));
        
        // Draw links
        const links = this.palaceVisualization.linksGroup.selectAll('line')
            .data(relationships.links)
            .enter().append('line')
            .attr('stroke', d => {
                if (d.type === 'hostile') return '#ff4757';
                if (d.type === 'romantic') return '#ff375f';
                if (d.type === 'allied') return '#00d4aa';
                return '#808080';
            })
            .attr('stroke-width', 2)
            .attr('stroke-opacity', 0.6);
        
        // Draw nodes
        const nodes = this.palaceVisualization.nodesGroup.selectAll('g')
            .data(relationships.nodes)
            .enter().append('g')
            .style('cursor', 'pointer')
            .call(d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended));
        
        nodes.append('circle')
            .attr('r', d => 10 + d.importance * 5)
            .attr('fill', d => {
                if (d.isPlayer) return '#667eea';
                if (d.isPartyMember) return '#00d4aa';
                if (d.isDead) return '#666';
                return '#00a884';
            })
            .attr('stroke', '#fff')
            .attr('stroke-width', 2);
        
        // Add character names
        nodes.append('text')
            .attr('class', 'node-label')
            .attr('dy', d => 15 + d.importance * 5 + 10)
            .text(d => d.id)
            .style('font-size', '12px');
        
        // Add hover
        nodes
            .on('mouseover', (event, d) => this.showRelationshipTooltip(event, d))
            .on('mouseout', () => this.hidePalaceTooltip());
        
        // Update positions on tick
        simulation.on('tick', () => {
            links
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);
            
            nodes.attr('transform', d => `translate(${d.x},${d.y})`);
        });
        
        // Drag functions
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }
        
        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }
        
        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
        
        this.updatePalaceInfo('relationships', relationships.nodes.length);
    }
    
    renderLocationMap() {
        if (!this.palaceVisualization || typeof d3 === 'undefined') {
            console.error('Cannot render locations - visualization not ready');
            return;
        }
        
        const locations = this.getLocationData();
        const width = this.palaceVisualization.width;
        const height = this.palaceVisualization.height;
        
        if (locations.length === 0) {
            this.updatePalaceInfo('locations', 0);
            return;
        }
        
        // Create hexagonal grid layout
        const hexRadius = 30;
        const hexHeight = hexRadius * 2;
        const hexWidth = hexRadius * Math.sqrt(3);
        
        // Position locations in a hex grid
        locations.forEach((loc, i) => {
            const row = Math.floor(i / 10);
            const col = i % 10;
            loc.x = col * hexWidth * 0.75 + hexWidth + (row % 2 ? hexWidth * 0.375 : 0);
            loc.y = row * hexHeight * 0.5 + hexHeight;
        });
        
        // Draw location hexagons
        const hexPath = d3.range(6).map(i => {
            const angle = (Math.PI / 3) * i - Math.PI / 6;
            return [
                hexRadius * Math.cos(angle),
                hexRadius * Math.sin(angle)
            ];
        });
        
        const locations_g = this.palaceVisualization.nodesGroup.selectAll('g')
            .data(locations)
            .enter().append('g')
            .attr('transform', d => `translate(${d.x},${d.y})`)
            .style('cursor', 'pointer');
        
        locations_g.append('path')
            .attr('d', 'M' + hexPath.join('L') + 'Z')
            .attr('fill', d => {
                const visits = d.visits || 0;
                const opacity = Math.min(0.1 + visits * 0.1, 1);
                return `rgba(0, 212, 170, ${opacity})`;
            })
            .attr('stroke', '#00d4aa')
            .attr('stroke-width', 2);
        
        // Add location names
        locations_g.append('text')
            .attr('class', 'node-label')
            .attr('dy', 5)
            .text(d => d.name)
            .style('font-size', '11px')
            .each(function(d) {
                // Wrap long text
                const text = d3.select(this);
                const words = d.name.split(/\s+/);
                if (words.length > 2) {
                    text.text('');
                    text.append('tspan')
                        .attr('x', 0)
                        .attr('dy', -5)
                        .text(words.slice(0, 2).join(' '));
                    text.append('tspan')
                        .attr('x', 0)
                        .attr('dy', 12)
                        .text(words.slice(2).join(' '));
                }
            });
        
        // Add hover
        locations_g
            .on('mouseover', (event, d) => this.showLocationTooltip(event, d))
            .on('mouseout', () => this.hidePalaceTooltip());
        
        this.updatePalaceInfo('locations', locations.length);
    }
    
    renderMemoryHeatmap() {
        if (!this.palaceVisualization || typeof d3 === 'undefined') {
            console.error('Cannot render heatmap - visualization not ready');
            return;
        }
        
        const memoryData = this.getMemoryHeatmapData();
        const width = this.palaceVisualization.width;
        const height = this.palaceVisualization.height;
        
        // Create grid
        const cellSize = 20;
        const cols = Math.floor(width / cellSize);
        const rows = Math.floor(height / cellSize);
        
        // Color scale
        const maxDensity = d3.max(memoryData, d => d.density) || 1;
        const colorScale = d3.scaleSequential(d3.interpolateInferno)
            .domain([0, maxDensity]);
        
        // Draw heatmap cells
        this.palaceVisualization.nodesGroup.selectAll('rect')
            .data(memoryData)
            .enter().append('rect')
            .attr('x', d => d.col * cellSize)
            .attr('y', d => d.row * cellSize)
            .attr('width', cellSize - 1)
            .attr('height', cellSize - 1)
            .attr('fill', d => colorScale(d.density))
            .style('cursor', 'pointer')
            .on('mouseover', (event, d) => this.showMemoryTooltip(event, d))
            .on('mouseout', () => this.hidePalaceTooltip());
        
        this.updatePalaceInfo('heatmap', memoryData.length);
    }
    
    // Data extraction methods
    getSceneData() {
        const scenes = [];
        let sceneIndex = 0;
        
        this.messageHistory.forEach((msg, i) => {
            if (msg.role === 'assistant' && msg.content.includes('narrative-content')) {
                const userAction = i > 0 ? this.messageHistory[i - 1]?.content : '';
                scenes.push({
                    index: sceneIndex++,
                    messageId: msg.id,
                    timestamp: msg.timestamp,
                    userAction: userAction,
                    hasQuest: msg.content.includes('quest') || msg.content.includes('Quest'),
                    hasCombat: msg.content.toLowerCase().includes('attack') || msg.content.toLowerCase().includes('fight')
                });
            }
        });
        
        return scenes;
    }
    
    getRelationshipData() {
        const nodes = [];
        const links = [];
        
        // Add player character
        if (this.currentStory?.character) {
            nodes.push({
                id: this.currentStory.character.name,
                importance: 3,
                isPlayer: true
            });
        }
        
        // Add all NPCs
        Object.entries(this.relationships).forEach(([name, data]) => {
            nodes.push({
                id: data.name || name.charAt(0).toUpperCase() + name.slice(1),
                importance: Math.min(data.interactions || 1, 5),
                isPartyMember: this.partyMembers.some(m => m.name.toLowerCase() === name),
                isDead: data.status === 'Dead'
            });
        });
        
        // Create links
        if (this.currentStory?.character) {
            Object.entries(this.relationships).forEach(([name, data]) => {
                links.push({
                    source: this.currentStory.character.name,
                    target: data.name || name.charAt(0).toUpperCase() + name.slice(1),
                    strength: Math.min((data.interactions || 1) / 10, 1),
                    type: this.categorizeRelationship(data.relationship)
                });
            });
        }
        
        return { nodes, links };
    }
    
    categorizeRelationship(relationship) {
        const lower = (relationship || '').toLowerCase();
        if (lower.includes('hostile') || lower.includes('enemy')) return 'hostile';
        if (lower.includes('romantic') || lower.includes('love')) return 'romantic';
        if (lower.includes('ally') || lower.includes('friend')) return 'allied';
        return 'neutral';
    }
    
    getLocationData() {
        const locations = [];
        
        Object.entries(this.contextMemory.locationMemory || {}).forEach(([name, data]) => {
            locations.push({
                name: name,
                visits: data.visits,
                firstVisit: data.firstVisit,
                lastVisit: data.lastVisit,
                description: data.description
            });
        });
        
        return locations.sort((a, b) => a.firstVisit - b.firstVisit);
    }
    
    getMemoryHeatmapData() {
        const cellSize = 20;
        const width = this.palaceVisualization.width;
        const height = this.palaceVisualization.height;
        const cols = Math.floor(width / cellSize);
        const rows = Math.floor(height / cellSize);
        
        const grid = [];
        const totalScenes = this.currentStory?.sceneCount || 0;
        
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                const sceneRange = {
                    start: Math.floor((row * cols + col) / (rows * cols) * totalScenes),
                    end: Math.floor((row * cols + col + 1) / (rows * cols) * totalScenes)
                };
                
                const density = this.calculateMemoryDensity(sceneRange);
                
                grid.push({
                    row,
                    col,
                    density,
                    sceneRange,
                    facts: []
                });
            }
        }
        
        return grid;
    }
    
    calculateMemoryDensity(sceneRange) {
        let density = 0;
        
        // Count facts in range
        Object.values(this.contextMemory.worldFacts || {}).forEach(facts => {
            facts.forEach(fact => {
                if (fact.scene >= sceneRange.start && fact.scene < sceneRange.end) {
                    density++;
                }
            });
        });
        
        return density;
    }
    
    // Tooltip methods
    showPalaceTooltip(event, data) {
        const tooltip = document.getElementById('palace-tooltip');
        if (!tooltip) return;
        
        tooltip.style.display = 'block';
        tooltip.style.left = event.pageX + 10 + 'px';
        tooltip.style.top = event.pageY - 10 + 'px';
        tooltip.classList.add('visible');
        
        tooltip.innerHTML = `
            <strong>Scene ${data.index + 1}</strong><br>
            <span style="color: var(--text-secondary); font-size: 12px;">
                ${new Date(data.timestamp).toLocaleString()}
            </span><br>
            ${data.userAction ? `<em>"${data.userAction.substring(0, 50)}..."</em><br>` : ''}
            ${data.hasQuest ? '<span style="color: var(--accent-warning);">✦ Quest Scene</span><br>' : ''}
            ${data.hasCombat ? '<span style="color: var(--accent-danger);">⚔ Combat Scene</span>' : ''}
        `;
    }
    
    showRelationshipTooltip(event, data) {
        const tooltip = document.getElementById('palace-tooltip');
        if (!tooltip) return;
        
        tooltip.style.display = 'block';
        tooltip.style.left = event.pageX + 10 + 'px';
        tooltip.style.top = event.pageY - 10 + 'px';
        tooltip.classList.add('visible');
        
        const relationship = this.relationships[data.id.toLowerCase()] || {};
        
        tooltip.innerHTML = `
            <strong>${data.id}</strong><br>
            ${data.isPlayer ? '<span style="color: var(--accent-primary);">★ You</span><br>' : ''}
            ${data.isPartyMember ? '<span style="color: var(--accent-success);">✓ Party Member</span><br>' : ''}
            Status: ${relationship.status || 'Unknown'}<br>
            Relationship: ${relationship.relationship || 'Neutral'}<br>
            Interactions: ${data.importance || 0}
        `;
    }
    
    showLocationTooltip(event, data) {
        const tooltip = document.getElementById('palace-tooltip');
        if (!tooltip) return;
        
        tooltip.style.display = 'block';
        tooltip.style.left = event.pageX + 10 + 'px';
        tooltip.style.top = event.pageY - 10 + 'px';
        tooltip.classList.add('visible');
        
        tooltip.innerHTML = `
            <strong>${data.name}</strong><br>
            Visits: ${data.visits}<br>
            First visited: Scene ${data.firstVisit}<br>
            Last visited: Scene ${data.lastVisit}
        `;
    }
    
    showMemoryTooltip(event, data) {
        const tooltip = document.getElementById('palace-tooltip');
        if (!tooltip) return;
        
        tooltip.style.display = 'block';
        tooltip.style.left = event.pageX + 10 + 'px';
        tooltip.style.top = event.pageY - 10 + 'px';
        tooltip.classList.add('visible');
        
        tooltip.innerHTML = `
            <strong>Memory Cluster</strong><br>
            Scenes ${data.sceneRange.start + 1}-${data.sceneRange.end}<br>
            Density: ${data.density} memories
        `;
    }
    
    hidePalaceTooltip() {
        const tooltip = document.getElementById('palace-tooltip');
        if (!tooltip) return;
        
        tooltip.classList.remove('visible');
        setTimeout(() => {
            if (!tooltip.classList.contains('visible')) {
                tooltip.style.display = 'none';
            }
        }, 300);
    }
    
    jumpToMemory(sceneData) {
        this.hideMemoryPalace();
        
        const message = this.messageHistory.find(m => m.id === sceneData.messageId);
        if (message) {
            const element = document.querySelector(`[data-message-id="${message.id}"]`);
            if (element) {
                element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                element.style.background = 'var(--accent-primary)';
                element.style.opacity = '0.2';
                setTimeout(() => {
                    element.style.background = '';
                    element.style.opacity = '';
                }, 2000);
            }
        }
    }
    
    updatePalaceInfo(viewType, count) {
        const info = document.getElementById('palace-info');
        if (!info) return;
        
        const descriptions = {
            timeline: `Viewing ${count} scenes across your narrative timeline.`,
            relationships: `${count} characters connected in your story.`,
            locations: `${count} locations discovered in your journey.`,
            heatmap: `Memory density visualization across ${this.currentStory?.sceneCount || 0} scenes.`
        };
        
        info.innerHTML = `
            <h3 style="margin-bottom: 8px;">Memory Palace - ${viewType.charAt(0).toUpperCase() + viewType.slice(1)}</h3>
            <p style="font-size: 13px; color: var(--text-secondary);">
                ${descriptions[viewType]}
            </p>
        `;
    }
    
    // ============================================
    // HELPER FUNCTIONS
    // ============================================
    
    trackChoicePattern(choice) {
        // Track patterns for predictive loading
        const pattern = choice.substring(0, 20);
        this.choicePredictions.patterns[pattern] = (this.choicePredictions.patterns[pattern] || 0) + 1;
        this.choicePredictions.history.push({
            choice: pattern,
            scene: this.currentStory?.sceneCount || 0
        });
        
        // Keep only last 50 choices
        if (this.choicePredictions.history.length > 50) {
            this.choicePredictions.history = this.choicePredictions.history.slice(-50);
        }
    }
    
    initializeWebWorker() {
        // Web Worker for background processing (would be in separate file in production)
        const workerCode = `
            self.onmessage = function(e) {
                const { type, data } = e.data;
                
                switch(type) {
                    case 'compress':
                        // Simple compression simulation
                        const compressed = data.substring(0, Math.floor(data.length * 0.3));
                        self.postMessage({ type: 'compressed', data: compressed });
                        break;
                        
                    case 'analyze':
                        // Pattern analysis
                        const patterns = {};
                        const words = data.split(' ');
                        words.forEach(word => {
                            patterns[word] = (patterns[word] || 0) + 1;
                        });
                        self.postMessage({ type: 'analyzed', data: patterns });
                        break;
                }
            };
        `;
        
        const blob = new Blob([workerCode], { type: 'application/javascript' });
        const workerUrl = URL.createObjectURL(blob);
        
        try {
            this.worker = new Worker(workerUrl);
            this.worker.onmessage = (e) => {
                console.log('Worker message:', e.data);
            };
        } catch (error) {
            console.log('Web Worker not supported, using main thread');
        }
        
        URL.revokeObjectURL(workerUrl);
    }
    
    // ============================================
    // GPT API WITH RETRY AND ERROR HANDLING
    // ============================================
    
    async callGPT(messages, temperature = 0.8, maxTokens = 1000) {
        try {
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.apiKey}`
                },
                body: JSON.stringify({
                    model: 'gpt-4o-mini',
                    messages: messages,
                    temperature: temperature,
                    max_tokens: maxTokens,
                    presence_penalty: 0.6,
                    frequency_penalty: 0.3
                })
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error?.message || 'API request failed');
            }
            
            const data = await response.json();
            return data.choices[0].message.content;
            
        } catch (error) {
            console.error('GPT API error:', error);
            
            // Handle rate limits
            if (error.message.includes('rate limit')) {
                await new Promise(resolve => setTimeout(resolve, 5000));
                return this.callGPT(messages, temperature, maxTokens);
            }
            
            throw error;
        }
    }
}

// ============================================
// INITIALIZE APP WITH ENHANCED ERROR HANDLING
// ============================================

// Wait for window to be fully loaded
window.addEventListener('load', () => {
    console.log('[Init] Window loaded, creating VirtueSeekers app...');
    
    try {
        // Create app and expose globally
        window.app = new VirtueSeekers();
        console.log('[Init] ✅ App created successfully');
        
        // Verify app methods are available
        const criticalMethods = ['showMenu', 'hideMenu', 'sendAction', 'submitApiKey'];
        let allMethodsPresent = true;
        
        criticalMethods.forEach(method => {
            if (typeof window.app[method] !== 'function') {
                console.error(`[Init] ❌ Missing critical method: ${method}`);
                allMethodsPresent = false;
            } else {
                console.log(`[Init] ✓ Method available: ${method}`);
            }
        });
        
        if (allMethodsPresent) {
            console.log('[Init] 🎮 Virtue Seekers Infinity Engine is ready!');
            
            // Update UI to show app is ready
            const menuButton = document.querySelector('.menu-button');
            if (menuButton) {
                menuButton.style.transition = 'all 0.3s ease';
                menuButton.style.opacity = '1';
                menuButton.style.transform = 'scale(1)';
            }
        }
        
    } catch (error) {
        console.error('[Init] ❌ Failed to create app:', error);
        
        // Show error message
        const messages = document.getElementById('chat-messages');
        if (messages) {
            messages.innerHTML = `
                <div class="message system">
                    <div class="message-content">
                        <p style="color: var(--accent-danger);">Failed to initialize the Infinity Engine.</p>
                        <p>Error: ${error.message}</p>
                        <button class="send-button" onclick="location.reload()">Reload Page</button>
                    </div>
                </div>
            `;
        }
    }
});

// ============================================
// TESTING SUITE - Verify Everything Works
// ============================================

// Automated test that runs after app loads
window.addEventListener('load', () => {
    setTimeout(() => {
        console.log('\n🧪 RUNNING AUTOMATED TESTS...\n');
        
        // Test 1: Check if app exists
        console.log('Test 1 - App Existence:', window.app ? '✅ PASS' : '❌ FAIL');
        
        // Test 2: Check if showMenu exists on app
        console.log('Test 2 - showMenu Method:', 
            (window.app && typeof window.app.showMenu === 'function') ? '✅ PASS' : '❌ FAIL');
        
        // Test 3: Check if global appCall works
        try {
            console.log('Test 3 - Global appCall:');
            window.appCall('testMethod'); // This will fail but shouldn't crash
            console.log('✅ PASS - No crash on missing method');
        } catch (e) {
            console.log('❌ FAIL - appCall crashed:', e);
        }
        
        // Test 4: Check if direct showMenu works
        console.log('Test 4 - Direct showMenu:', 
            typeof window.showMenu === 'function' ? '✅ PASS' : '❌ FAIL');
        
        // Test 5: Check menu button
        const menuButton = document.querySelector('.menu-button');
        console.log('Test 5 - Menu Button Exists:', menuButton ? '✅ PASS' : '❌ FAIL');
        
        // Test 6: Simulate menu button click
        if (menuButton && window.app && window.app.showMenu) {
            console.log('Test 6 - Simulating Menu Click...');
            try {
                // Create a fake click event
                const clickEvent = new MouseEvent('click', {
                    view: window,
                    bubbles: true,
                    cancelable: true
                });
                menuButton.dispatchEvent(clickEvent);
                
                // Check if menu modal is visible
                setTimeout(() => {
                    const menuModal = document.getElementById('menu-modal');
                    const isVisible = menuModal && !menuModal.classList.contains('hidden');
                    console.log('Test 6 - Menu Opens:', isVisible ? '✅ PASS' : '❌ FAIL');
                    
                    // Close menu if it opened
                    if (isVisible && window.app.hideMenu) {
                        window.app.hideMenu();
                        console.log('Test 6b - Menu Closes: ✅ PASS');
                    }
                    
                    console.log('\n🎉 TESTING COMPLETE!\n');
                    console.log('The Narrative Infinity Engine is ready for infinite storytelling! 🌌');
                }, 100);
                
            } catch (e) {
                console.log('Test 6 - Menu Click: ❌ FAIL -', e);
            }
        }
        
    }, 1000); // Wait 1 second after load to ensure app is initialized
});