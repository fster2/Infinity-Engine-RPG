<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#212121">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    <title>Virtue Seekers - Infinity Engine</title>
    
    <!-- Modern Font Stack -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Söhne:wght@400;500;600&family=Monaco&display=swap" rel="stylesheet">
    
    <style>
        /* ================================
           CHATGPT DARK MODE DESIGN SYSTEM
           ================================ */
        :root {
            /* ChatGPT Dark Theme Colors */
            --bg-primary: #212121;
            --bg-secondary: #2d2d2d;
            --bg-tertiary: #424242;
            --bg-chat: #343541;
            
            /* Text */
            --text-primary: #ececf1;
            --text-secondary: #d1d5db;
            --text-tertiary: #acacbe;
            
            /* Accent */
            --accent-primary: #10a37f;
            --accent-hover: #1a7f64;
            
            /* Message Bubbles */
            --user-bg: #343541;
            --assistant-bg: #444654;
            
            /* Borders */
            --border-primary: #4e4e5f;
            --border-secondary: #353541;
            
            /* Shadows */
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background: var(--bg-primary);
            color: var(--text-primary);
            font-family: Söhne, -apple-system, BlinkMacSystemFont, Helvetica, sans-serif;
            font-size: 14px;
            line-height: 1.6;
            min-height: 100vh;
            overflow: hidden;
        }

        /* Main Layout */
        #app {
            display: flex;
            flex-direction: column;
            height: 100vh;
            position: relative;
        }

        /* Header */
        .app-header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-secondary);
            padding: 12px 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }

        .app-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .save-indicator {
            font-size: 12px;
            color: var(--text-tertiary);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .save-dot {
            width: 6px;
            height: 6px;
            background: var(--accent-primary);
            border-radius: 50%;
            opacity: 0;
            animation: pulse 2s infinite;
        }

        .save-dot.active {
            opacity: 1;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 1; }
        }

        .menu-button {
            background: transparent;
            border: 1px solid var(--border-primary);
            color: var(--text-secondary);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .menu-button:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        /* Chat Container */
        .chat-container {
            flex: 1;
            overflow-y: auto;
            background: var(--bg-chat);
        }

        .chat-messages {
            max-width: 800px;
            margin: 0 auto;
            padding: 24px 0;
        }

        /* Message Styles */
        .message {
            padding: 24px 48px;
            border-bottom: 1px solid var(--border-secondary);
        }

        .message.user {
            background: var(--user-bg);
        }

        .message.assistant {
            background: var(--assistant-bg);
        }

        .message-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .message-avatar {
            width: 30px;
            height: 30px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 14px;
        }

        .user .message-avatar {
            background: #5436da;
            color: white;
        }

        .assistant .message-avatar {
            background: var(--accent-primary);
            color: white;
        }

        .message-role {
            font-weight: 600;
            font-size: 14px;
        }

        .message-content {
            margin-left: 42px;
            color: var(--text-primary);
        }

        /* Narrative Sections */
        .narrative-section {
            margin: 16px 0;
        }

        .section-label {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .section-content {
            text-align: left;
            line-height: 1.7;
        }

        .section-content p {
            margin-bottom: 12px;
        }

        .section-content p:last-child {
            margin-bottom: 0;
        }

        /* Dialogue Boxes */
        .dialogue-container {
            margin: 16px 0;
        }

        .dialogue-box {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 8px;
        }

        .dialogue-speaker {
            font-weight: 600;
            color: var(--accent-primary);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .dialogue-tone {
            font-size: 12px;
            color: var(--text-tertiary);
            font-style: italic;
            margin-bottom: 4px;
        }

        .dialogue-text {
            color: var(--text-primary);
        }

        /* Choice Cards */
        .choices-grid {
            display: grid;
            gap: 8px;
            margin: 16px 0;
        }

        .choice-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 12px 16px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .choice-card:hover {
            background: var(--bg-tertiary);
            border-color: var(--accent-primary);
        }

        .choice-number {
            background: var(--accent-primary);
            color: var(--bg-primary);
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 12px;
            flex-shrink: 0;
        }

        .choice-text {
            flex: 1;
            color: var(--text-primary);
        }

        /* Input Area */
        .input-container {
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-secondary);
            padding: 16px;
            flex-shrink: 0;
        }

        .input-wrapper {
            max-width: 800px;
            margin: 0 auto;
            display: flex;
            gap: 12px;
            align-items: flex-end;
        }

        .custom-input {
            flex: 1;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 12px 16px;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 14px;
            resize: none;
            min-height: 44px;
            max-height: 200px;
            line-height: 1.5;
        }

        .custom-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .send-button {
            background: var(--accent-primary);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 10px 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .send-button:hover {
            background: var(--accent-hover);
        }

        .send-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Character Creation */
        .creation-form {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 24px;
            margin: 16px 0;
        }

        .form-grid {
            display: grid;
            gap: 16px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .form-label {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .form-input {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 6px;
            padding: 8px 12px;
            color: var(--text-primary);
            font-size: 14px;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .form-textarea {
            min-height: 80px;
            resize: vertical;
            font-family: inherit;
        }

        .optional-tag {
            font-size: 11px;
            color: var(--text-tertiary);
            font-weight: normal;
        }

        /* Class Selection */
        .class-grid {
            display: grid;
            gap: 12px;
            margin: 16px 0;
        }

        .class-option {
            background: var(--bg-secondary);
            border: 2px solid transparent;
            border-radius: 8px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .class-option:hover {
            border-color: var(--accent-primary);
            background: var(--bg-tertiary);
        }

        .class-option.selected {
            border-color: var(--accent-primary);
            background: var(--bg-tertiary);
        }

        .class-name {
            font-weight: 600;
            font-size: 16px;
            margin-bottom: 6px;
        }

        .class-description {
            color: var(--text-secondary);
            font-size: 13px;
        }

        /* Menu Modal */
        .menu-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .menu-content {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .menu-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .menu-title {
            font-size: 18px;
            font-weight: 600;
        }

        .close-button {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-button:hover {
            color: var(--text-primary);
        }

        .menu-section {
            margin-bottom: 24px;
        }

        .menu-section-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .menu-button-grid {
            display: grid;
            gap: 8px;
        }

        .menu-action {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 12px 16px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }

        .menu-action:hover {
            background: var(--bg-primary);
            border-color: var(--accent-primary);
        }

        /* Character Sheet */
        .character-sheet {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 20px;
        }

        .character-stat-grid {
            display: grid;
            gap: 16px;
        }

        .stat-group {
            border-bottom: 1px solid var(--border-primary);
            padding-bottom: 16px;
        }

        .stat-group:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }

        .stat-label {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }

        .stat-value {
            color: var(--text-primary);
            font-size: 14px;
        }

        .stat-list {
            list-style: none;
            padding: 0;
        }

        .stat-list li {
            padding: 4px 0;
            color: var(--text-secondary);
        }

        /* Loading */
        .loading {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
        }

        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid var(--border-primary);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-right: 12px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Regenerate Button */
        .regenerate-button {
            background: transparent;
            border: 1px solid var(--border-primary);
            color: var(--text-secondary);
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            margin-top: 12px;
        }

        .regenerate-button:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border-color: var(--accent-primary);
        }

        /* Remove Buttons for Trackers */
        .stat-group {
            position: relative;
            padding-right: 30px;
        }
        
        .stat-group .close-button {
            position: absolute;
            right: 0;
            top: 0;
            width: 24px;
            height: 24px;
            font-size: 16px;
            background: transparent;
            border: 1px solid var(--border-primary);
            color: var(--text-tertiary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .stat-group .close-button:hover {
            background: var(--accent-danger);
            border-color: var(--accent-danger);
            color: white;
        }
        
        /* Quest Objectives */
        .stat-list li {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* Utility */
        .hidden {
            display: none !important;
        }

        /* Mobile */
        @media (max-width: 600px) {
            .message {
                padding: 16px 24px;
            }
            
            .menu-content {
                width: 95%;
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- Header -->
        <header class="app-header">
            <div class="app-title">Virtue Seekers</div>
            <div class="header-controls">
                <div class="save-indicator">
                    <div class="save-dot" id="save-indicator"></div>
                    <span id="save-text">Saved</span>
                </div>
                <button class="menu-button" onclick="app.showMenu()">Menu</button>
            </div>
        </header>

        <!-- Chat Container -->
        <div class="chat-container" id="chat-container">
            <div class="chat-messages" id="chat-messages">
                <!-- Messages will be inserted here -->
            </div>
        </div>

        <!-- Input Area -->
        <div class="input-container">
            <div class="input-wrapper">
                <textarea 
                    id="custom-input" 
                    class="custom-input" 
                    placeholder="What do you do?"
                    rows="1"></textarea>
                <button id="send-button" class="send-button" onclick="app.sendAction()">Send</button>
            </div>
        </div>

        <!-- Menu Modal (hidden by default) -->
        <div id="menu-modal" class="menu-modal hidden">
            <div class="menu-content">
                <div class="menu-header">
                    <h2 class="menu-title">Menu</h2>
                    <button class="close-button" onclick="app.hideMenu()">×</button>
                </div>
                
                <div class="menu-section">
                    <h3 class="menu-section-title">Character</h3>
                    <div class="menu-button-grid">
                        <button class="menu-action" onclick="app.showCharacterSheet()">View Character Sheet</button>
                        <button class="menu-action" onclick="app.showPartyMembers()">Party Members</button>
                        <button class="menu-action" onclick="app.showQuestJournal()">Quest Journal</button>
                        <button class="menu-action" onclick="app.showRelationships()">Relationship Tracker</button>
                    </div>
                </div>
                
                <div class="menu-section">
                    <h3 class="menu-section-title">Story</h3>
                    <div class="menu-button-grid">
                        <button class="menu-action" onclick="app.exportStory()">Export Story</button>
                        <button class="menu-action" onclick="app.searchHistory()">Search History</button>
                        <button class="menu-action" onclick="app.showStats()">Story Statistics</button>
                    </div>
                </div>
                
                <div class="menu-section">
                    <h3 class="menu-section-title">System</h3>
                    <div class="menu-button-grid">
                        <button class="menu-action" onclick="app.changeApiKey()">Change API Key</button>
                        <button class="menu-action" onclick="app.clearData()">Start New Story</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
// ============================================
// VIRTUE SEEKERS INFINITY ENGINE - CHAT STYLE
// ============================================

class VirtueSeekers {
    constructor() {
        this.apiKey = null;
        this.currentStory = null;
        this.messageHistory = [];
        this.isProcessing = false;
        this.partyMembers = [];
        this.questJournal = [];
        this.relationships = {};
        
        // Storage
        this.STORAGE_PREFIX = 'virtue_seekers_';
        this.STORAGE_KEYS = {
            API_KEY: 'api_key',
            CURRENT_STORY: 'current_story',
            MESSAGE_HISTORY: 'message_history',
            PARTY_MEMBERS: 'party_members',
            WORLD_STATE: 'world_state',
            QUEST_JOURNAL: 'quest_journal',
            RELATIONSHIPS: 'relationships'
        };
        
        // Auto-save timer
        this.autoSaveInterval = null;
    }
    
    async initialize() {
        // Load saved data
        this.apiKey = this.getFromStorage(this.STORAGE_KEYS.API_KEY);
        this.currentStory = this.getFromStorage(this.STORAGE_KEYS.CURRENT_STORY);
        this.messageHistory = this.getFromStorage(this.STORAGE_KEYS.MESSAGE_HISTORY) || [];
        this.partyMembers = this.getFromStorage(this.STORAGE_KEYS.PARTY_MEMBERS) || [];
        this.questJournal = this.getFromStorage(this.STORAGE_KEYS.QUEST_JOURNAL) || [];
        this.relationships = this.getFromStorage(this.STORAGE_KEYS.RELATIONSHIPS) || {};
        
        // Set up UI
        this.setupInputHandlers();
        this.setupKeyboardShortcuts();
        
        // Start auto-save
        this.startAutoSave();
        
        if (!this.apiKey) {
            this.showApiKeyPrompt();
        } else if (this.messageHistory.length > 0) {
            this.displayMessageHistory();
        } else {
            this.startNewStory();
        }
    }
    
    // ============================================
    // UI SETUP
    // ============================================
    
    setupInputHandlers() {
        const input = document.getElementById('custom-input');
        
        // Auto-resize textarea
        input.addEventListener('input', () => {
            input.style.height = 'auto';
            input.style.height = input.scrollHeight + 'px';
        });
        
        // Handle Enter (send) vs Shift+Enter (new line)
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                this.sendAction();
            }
        });
    }
    
    setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
            // Escape to show menu
            if (e.key === 'Escape') {
                this.toggleMenu();
            }
            
            // Number keys for choices
            if (!this.isProcessing && e.key >= '1' && e.key <= '4') {
                const choices = document.querySelectorAll('.choice-card');
                const index = parseInt(e.key) - 1;
                if (choices[index]) {
                    choices[index].click();
                }
            }
        });
    }
    
    // ============================================
    // STORAGE
    // ============================================
    
    saveToStorage(key, value) {
        try {
            localStorage.setItem(this.STORAGE_PREFIX + key, JSON.stringify(value));
            this.showSaveIndicator();
        } catch (e) {
            console.error('Storage failed:', e);
        }
    }
    
    getFromStorage(key) {
        try {
            const item = localStorage.getItem(this.STORAGE_PREFIX + key);
            return item ? JSON.parse(item) : null;
        } catch (e) {
            console.error('Storage read failed:', e);
            return null;
        }
    }
    
    showSaveIndicator() {
        const dot = document.getElementById('save-indicator');
        const text = document.getElementById('save-text');
        
        dot.classList.add('active');
        text.textContent = 'Saving...';
        
        setTimeout(() => {
            dot.classList.remove('active');
            text.textContent = 'Saved';
        }, 1000);
    }
    
    startAutoSave() {
        this.autoSaveInterval = setInterval(() => {
            if (this.messageHistory.length > 0) {
                this.saveToStorage(this.STORAGE_KEYS.MESSAGE_HISTORY, this.messageHistory);
                this.saveToStorage(this.STORAGE_KEYS.CURRENT_STORY, this.currentStory);
                this.saveToStorage(this.STORAGE_KEYS.PARTY_MEMBERS, this.partyMembers);
                this.saveToStorage(this.STORAGE_KEYS.QUEST_JOURNAL, this.questJournal);
                this.saveToStorage(this.STORAGE_KEYS.RELATIONSHIPS, this.relationships);
            }
        }, 30000); // Every 30 seconds
    }
    
    // ============================================
    // API KEY MANAGEMENT
    // ============================================
    
    showApiKeyPrompt() {
        this.addMessage('system', `
            <div class="creation-form">
                <h2 style="margin-bottom: 16px;">Welcome to Virtue Seekers</h2>
                <p style="margin-bottom: 20px; color: var(--text-secondary);">
                    To begin your infinite narrative journey, please enter your OpenAI API key.
                    Your key is stored locally and never shared.
                </p>
                <div class="form-group">
                    <label class="form-label">OpenAI API Key</label>
                    <input type="password" id="api-key-input" class="form-input" placeholder="sk-...">
                </div>
                <div style="margin-top: 16px;">
                    <button class="send-button" onclick="app.submitApiKey()">Begin Adventure</button>
                </div>
                <p style="margin-top: 16px; font-size: 12px; color: var(--text-tertiary);">
                    Need a key? <a href="https://platform.openai.com/api-keys" target="_blank" style="color: var(--accent-primary);">Get one from OpenAI →</a>
                </p>
            </div>
        `);
    }
    
    async submitApiKey() {
        const input = document.getElementById('api-key-input');
        const apiKey = input.value.trim();
        
        if (!apiKey || !apiKey.startsWith('sk-')) {
            alert('Please enter a valid OpenAI API key');
            return;
        }
        
        this.apiKey = apiKey;
        this.saveToStorage(this.STORAGE_KEYS.API_KEY, apiKey);
        this.clearChat();
        await this.startNewStory();
    }
    
    // ============================================
    // CHARACTER CREATION
    // ============================================
    
    async startNewStory() {
        this.currentStory = {
            id: Date.now(),
            character: null,
            sceneCount: 0,
            created: new Date().toISOString()
        };
        
        this.addMessage('assistant', `
            <h2 style="margin-bottom: 16px;">Create Your Character</h2>
            <p style="margin-bottom: 20px;">Tell me about your character. Fill in what you'd like - the rest will be generated procedurally.</p>
            
            <div class="creation-form" id="character-form">
                <div class="form-grid">
                    <div class="form-group">
                        <label class="form-label">Name <span class="optional-tag">(required)</span></label>
                        <input type="text" id="char-name" class="form-input" placeholder="Enter character name">
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Gender <span class="optional-tag">(optional)</span></label>
                        <input type="text" id="char-gender" class="form-input" placeholder="Any gender or leave blank">
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Appearance <span class="optional-tag">(optional)</span></label>
                        <textarea id="char-appearance" class="form-input form-textarea" placeholder="Describe how your character looks"></textarea>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Personality <span class="optional-tag">(optional)</span></label>
                        <textarea id="char-personality" class="form-input form-textarea" placeholder="Describe their personality traits"></textarea>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Alignment <span class="optional-tag">(optional)</span></label>
                        <input type="text" id="char-alignment" class="form-input" placeholder="e.g., Chaotic Good, True Neutral">
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">What They Love <span class="optional-tag">(optional)</span></label>
                        <input type="text" id="char-loves" class="form-input" placeholder="What brings them joy?">
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">What They Hate <span class="optional-tag">(optional)</span></label>
                        <input type="text" id="char-hates" class="form-input" placeholder="What do they despise?">
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Background <span class="optional-tag">(optional)</span></label>
                        <textarea id="char-background" class="form-input form-textarea" placeholder="Any backstory details?"></textarea>
                    </div>
                </div>
                
                <div style="margin-top: 20px;">
                    <button class="send-button" onclick="app.proceedToClassSelection()">Continue →</button>
                </div>
            </div>
        `);
        
        // Focus name field
        setTimeout(() => document.getElementById('char-name')?.focus(), 100);
    }
    
    async proceedToClassSelection() {
        const name = document.getElementById('char-name').value.trim();
        if (!name) {
            alert('Please enter a character name');
            return;
        }
        
        // Collect all character data
        const characterData = {
            name: name,
            gender: document.getElementById('char-gender').value.trim() || 'unspecified',
            appearance: document.getElementById('char-appearance').value.trim() || 'mysterious',
            personality: document.getElementById('char-personality').value.trim() || 'determined',
            alignment: document.getElementById('char-alignment').value.trim() || 'neutral',
            loves: document.getElementById('char-loves').value.trim() || 'adventure',
            hates: document.getElementById('char-hates').value.trim() || 'injustice',
            background: document.getElementById('char-background').value.trim() || 'unknown'
        };
        
        // Store character data temporarily
        this.currentStory.character = characterData;
        
        // Generate classes
        this.isProcessing = true;
        this.addMessage('system', '<div class="loading"><span class="spinner"></span>Discovering unique paths...</div>');
        
        const classes = await this.generateClasses(characterData);
        
        // Remove loading message
        this.removeLastMessage();
        
        this.addMessage('assistant', `
            <h2 style="margin-bottom: 16px;">Choose Your Path</h2>
            <p style="margin-bottom: 20px;">Select a class for ${name}:</p>
            
            <div class="class-grid" id="class-selection">
                ${classes.map((cls, i) => `
                    <div class="class-option" data-index="${i}" onclick="app.selectClass(${i})">
                        <div class="class-name">${cls.name}</div>
                        <div class="class-description">${cls.description}</div>
                    </div>
                `).join('')}
            </div>
            
            <button class="regenerate-button" onclick="app.regenerateClasses()">
                ↻ Show Different Classes
            </button>
        `);
        
        // Store classes for selection
        this.generatedClasses = classes;
        this.isProcessing = false;
    }
    
    async selectClass(index) {
        const selectedClass = this.generatedClasses[index];
        this.currentStory.character.class = selectedClass.name;
        this.currentStory.character.classDescription = selectedClass.description;
        
        // Save character
        this.saveToStorage(this.STORAGE_KEYS.CURRENT_STORY, this.currentStory);
        
        // Show user's selection
        this.addMessage('user', `I choose to be a ${selectedClass.name}.`);
        
        // Generate opening scene
        await this.generateOpeningScene();
    }
    
    async regenerateClasses() {
        if (this.isProcessing) return;
        
        this.isProcessing = true;
        this.addMessage('system', '<div class="loading"><span class="spinner"></span>Discovering new paths...</div>');
        
        const classes = await this.generateClasses(this.currentStory.character);
        
        this.removeLastMessage();
        
        // Update the class selection
        const classGrid = document.getElementById('class-selection');
        if (classGrid) {
            classGrid.innerHTML = classes.map((cls, i) => `
                <div class="class-option" data-index="${i}" onclick="app.selectClass(${i})">
                    <div class="class-name">${cls.name}</div>
                    <div class="class-description">${cls.description}</div>
                </div>
            `).join('');
        }
        
        this.generatedClasses = classes;
        this.isProcessing = false;
    }
    
    // ============================================
    // NARRATIVE GENERATION
    // ============================================
    
    async generateClasses(characterData) {
        try {
            const response = await this.callGPT([
                {
                    role: 'system',
                    content: `Generate 6 unique fantasy RPG classes tailored to this character: ${JSON.stringify(characterData)}. Each should be creative and unusual, not standard fantasy tropes. Return as JSON array with "name" and "description" fields. Keep descriptions to one compelling sentence.`
                },
                {
                    role: 'user',
                    content: 'Generate 6 unique character classes. Be creative and avoid clichés.'
                }
            ], 0.9, 400);
            
            const jsonMatch = response.match(/\[[\s\S]*\]/);
            if (jsonMatch) {
                return JSON.parse(jsonMatch[0]);
            }
        } catch (error) {
            console.error('Class generation failed:', error);
        }
        
        // Fallback classes
        return [
            { name: "Dreamwright", description: "Architects who build reality from the fragments of sleeping minds" },
            { name: "Voidbinder", description: "Those who forge contracts with the hungry spaces between stars" },
            { name: "Thornkeeper", description: "Guardians who cultivate gardens of living memory and painful beauty" },
            { name: "Echowalker", description: "Wanderers who step through the reverberations of past and future" },
            { name: "Glassweaver", description: "Artisans who spin fate itself from threads of crystallized time" },
            { name: "Shadowscribe", description: "Writers whose words cast living darkness across reality" }
        ];
    }
    
    async generateOpeningScene() {
        this.isProcessing = true;
        this.addMessage('system', '<div class="loading"><span class="spinner"></span>Weaving your story...</div>');
        
        const char = this.currentStory.character;
        const context = this.buildNarrativeContext();
        
        const messages = [
            {
                role: 'system',
                content: `You are a Fantasy RPG Game Master creating a Virtue Seekers narrative.
Your role is to craft immersive, purely fantasy narratives with magical, mysterious environments.

WORD COUNT: 500 words average (700 for combat scenes).

Character Details:
- Name: ${char.name}
- Class: ${char.class} (${char.classDescription})
- Gender: ${char.gender}
- Appearance: ${char.appearance}
- Personality: ${char.personality}
- Alignment: ${char.alignment}
- Loves: ${char.loves}
- Hates: ${char.hates}
- Background: ${char.background}

Structure your response EXACTLY as follows:

[Rich Environmental Description]
2-3 paragraphs with multiple sensory details (light, temperature, sounds, smells). Weave in magical elements like dancing will-o'-the-wisps or floating motes of light.

[Character Positions and Actions]
1 paragraph clearly indicating where each character stands, what they're doing, and any significant gear or abilities.

[Character Dialogue]
Format: Name: (tone/expression) "Dialogue."
Show distinct personalities, emotions, and interpersonal dynamics.

[Choice Presentation]
Provide 2-5 options formatted as:
1. [Action Option]: [Brief description]
2. [Action Option]: [Brief description]
3. [Action Option]: [Brief description]

[Scene-Closing Hook]
1 paragraph ending with tension, suspense, or a new revelation.`
            },
            {
                role: 'user',
                content: `Begin the adventure. ${char.name} the ${char.class} awakens in a mysterious location. Create a compelling opening scene.`
            }
        ];
        
        try {
            const response = await this.callGPT(messages, 0.8, 1000);
            
            this.removeLastMessage(); // Remove loading
            this.displayNarrativeResponse(response);
            
            this.currentStory.sceneCount++;
            this.saveToStorage(this.STORAGE_KEYS.CURRENT_STORY, this.currentStory);
            
        } catch (error) {
            this.removeLastMessage();
            this.addMessage('system', `Error: ${error.message}`);
        }
        
        this.isProcessing = false;
    }
    
    async handleChoice(choiceText) {
        if (this.isProcessing) return;
        
        this.addMessage('user', choiceText);
        
        this.isProcessing = true;
        this.addMessage('system', '<div class="loading"><span class="spinner"></span>Continuing the narrative...</div>');
        
        const context = this.buildNarrativeContext();
        
        const messages = [
            {
                role: 'system',
                content: `You are a Fantasy RPG Game Master creating a Virtue Seekers narrative.

WORD COUNT: 500 words average (700 for combat).

Remember all established facts:
${context}

Show the chosen action happening in detail, then continue the story.

Structure your response EXACTLY as follows:

[Rich Environmental Description]
2-3 paragraphs with multiple sensory details (light, temperature, sounds, smells). Include magical elements.

[Character Positions and Actions]
1 paragraph clearly indicating where each character stands and what they're doing.

[Character Dialogue]
Format: Name: (tone/expression) "Dialogue."
Show distinct personalities and emotions.

[Choice Presentation]
Provide 2-5 options formatted as:
1. [Action Option]: [Brief description]
2. [Action Option]: [Brief description]
3. [Action Option]: [Brief description]

[Scene-Closing Hook]
1 paragraph ending with tension, suspense, or revelation.`
            },
            {
                role: 'user',
                content: `The player chose: "${choiceText}"`
            }
        ];
        
        try {
            const response = await this.callGPT(messages, 0.8, 1000);
            
            this.removeLastMessage();
            this.displayNarrativeResponse(response);
            
            this.currentStory.sceneCount++;
            
        } catch (error) {
            this.removeLastMessage();
            this.addMessage('system', `Error: ${error.message}`);
        }
        
        this.isProcessing = false;
    }
    
    async sendAction() {
        const input = document.getElementById('custom-input');
        const action = input.value.trim();
        
        if (!action || this.isProcessing) return;
        
        // Clear input
        input.value = '';
        input.style.height = 'auto';
        
        // Check if this is a choice selection
        const choiceMatch = action.match(/^(\d)$/);
        if (choiceMatch) {
            const choiceNum = parseInt(choiceMatch[1]);
            const choices = this.lastChoices;
            if (choices && choices[choiceNum - 1]) {
                this.handleChoice(choices[choiceNum - 1]);
                return;
            }
        }
        
        // Custom action
        this.addMessage('user', action);
        
        this.isProcessing = true;
        this.addMessage('system', '<div class="loading"><span class="spinner"></span>Weaving your action into the story...</div>');
        
        const context = this.buildNarrativeContext();
        
        const messages = [
            {
                role: 'system',
                content: `You are a Fantasy RPG Game Master creating a Virtue Seekers narrative.

WORD COUNT: 500 words average.

Context: ${context}

The player wants to take a custom action. Show the attempted action in detail.
If the action seems impossible, show the attempt and realistic consequences.

Structure your response EXACTLY as follows:

[Rich Environmental Description]
2-3 paragraphs with multiple sensory details (light, temperature, sounds, smells). Include magical elements.

[Character Positions and Actions]
1 paragraph showing the custom action being attempted. Detail every step and movement.

[Character Dialogue]
Format: Name: (tone/expression) "Dialogue."
Include reactions to the custom action.

[Choice Presentation]
Provide 2-5 new options arising from this action:
1. [Action Option]: [Brief description]
2. [Action Option]: [Brief description]
3. [Action Option]: [Brief description]

[Scene-Closing Hook]
1 paragraph ending with tension or revelation.`
            },
            {
                role: 'user',
                content: `I attempt to: ${action}`
            }
        ];
        
        try {
            const response = await this.callGPT(messages, 0.8, 1000);
            
            this.removeLastMessage();
            this.displayNarrativeResponse(response);
            
        } catch (error) {
            this.removeLastMessage();
            this.addMessage('system', `Error: ${error.message}`);
        }
        
        this.isProcessing = false;
    }
    
    displayNarrativeResponse(response) {
        const sections = this.parseNarrativeResponse(response);
        
        let html = '<div class="narrative-content">';
        
        // Environmental Description
        if (sections.environmental) {
            html += `
                <div class="narrative-section">
                    <div class="section-label">Environmental Description</div>
                    <div class="section-content">${this.formatParagraphs(sections.environmental)}</div>
                </div>
            `;
        }
        
        // Character Positioning
        if (sections.positioning) {
            html += `
                <div class="narrative-section">
                    <div class="section-label">Character Positioning</div>
                    <div class="section-content">${this.formatParagraphs(sections.positioning)}</div>
                </div>
            `;
        }
        
        // Dialogue
        if (sections.dialogue && sections.dialogue.length > 0) {
            html += `
                <div class="narrative-section">
                    <div class="section-label">Dialogue</div>
                    <div class="dialogue-container">
            `;
            
            sections.dialogue.forEach(line => {
                html += `
                    <div class="dialogue-box">
                        <div class="dialogue-speaker">${line.speaker}</div>
                        <div class="dialogue-tone">(${line.tone})</div>
                        <div class="dialogue-text">${line.text}</div>
                    </div>
                `;
                
                // Auto-track NPCs from dialogue
                this.trackNPCFromDialogue(line.speaker);
            });
            
            html += '</div></div>';
        }
        
        // Available Actions
        if (sections.actions && sections.actions.length > 0) {
            html += `
                <div class="narrative-section">
                    <div class="section-label">Available Actions</div>
                    <div class="choices-grid">
            `;
            
            sections.actions.forEach((action, i) => {
                html += `
                    <div class="choice-card" onclick="app.handleChoice('${action.replace(/'/g, "\\'")}')">
                        <div class="choice-number">${i + 1}</div>
                        <div class="choice-text">${action}</div>
                    </div>
                `;
            });
            
            html += '</div></div>';
            
            // Store choices for keyboard shortcuts
            this.lastChoices = sections.actions;
        }
        
        // Scene Hook
        if (sections.hook) {
            html += `
                <div class="narrative-section">
                    <div class="section-label">Scene Hook</div>
                    <div class="section-content" style="font-style: italic;">${this.formatParagraphs(sections.hook)}</div>
                </div>
            `;
        }
        
        html += `
            <button class="regenerate-button" onclick="app.regenerateScene()">
                ↻ Regenerate Scene
            </button>
        </div>`;
        
        this.addMessage('assistant', html);
    }
    
    parseNarrativeResponse(text) {
        const sections = {
            environmental: '',
            positioning: '',
            dialogue: [],
            actions: [],
            hook: ''
        };
        
        // Split by section headers
        const parts = text.split(/\[([^\]]+)\]/);
        let currentSection = '';
        
        for (let i = 0; i < parts.length; i++) {
            const content = parts[i].trim();
            
            if (content.match(/Environmental Description/i)) {
                currentSection = 'environmental';
            } else if (content.match(/Character Positioning/i)) {
                currentSection = 'positioning';
            } else if (content.match(/Dialogue/i)) {
                currentSection = 'dialogue';
            } else if (content.match(/Available Actions/i)) {
                currentSection = 'actions';
            } else if (content.match(/Scene Hook/i)) {
                currentSection = 'hook';
            } else if (currentSection && content) {
                switch (currentSection) {
                    case 'environmental':
                        sections.environmental = content;
                        break;
                    case 'positioning':
                        sections.positioning = content;
                        break;
                    case 'dialogue':
                        // Parse dialogue lines with tone/expression
                        const lines = content.split('\n').filter(line => line.trim());
                        lines.forEach(line => {
                            // Match format: Name: (tone) "text" or Name: (tone) text
                            const match = line.match(/^([^:]+):\s*\(([^)]+)\)\s*"?(.+?)"?$/);
                            if (match) {
                                sections.dialogue.push({
                                    speaker: match[1].trim().toUpperCase(),
                                    tone: match[2].trim(),
                                    text: match[3].trim().replace(/^"|"$/g, '')
                                });
                            }
                        });
                        break;
                    case 'actions':
                        // Parse numbered actions
                        const actionLines = content.split('\n');
                        actionLines.forEach(line => {
                            const actionMatch = line.match(/^\d+\.\s*(.+)$/);
                            if (actionMatch) {
                                sections.actions.push(actionMatch[1].trim());
                            }
                        });
                        break;
                    case 'hook':
                        sections.hook = content;
                        break;
                }
            }
        }
        
        return sections;
    }
    
    formatParagraphs(text) {
        return text.split('\n\n')
            .map(para => para.trim())
            .filter(para => para)
            .map(para => `<p>${para}</p>`)
            .join('');
    }
    
    async regenerateScene() {
        if (this.isProcessing) return;
        
        // Find the last narrative message
        const lastNarrative = [...this.messageHistory].reverse().find(msg => 
            msg.role === 'assistant' && msg.content.includes('narrative-content')
        );
        
        if (!lastNarrative) return;
        
        // Remove it
        const index = this.messageHistory.indexOf(lastNarrative);
        this.messageHistory.splice(index, 1);
        this.displayMessageHistory();
        
        // Regenerate with higher temperature
        this.isProcessing = true;
        this.addMessage('system', '<div class="loading"><span class="spinner"></span>Reweaving the narrative...</div>');
        
        const context = this.buildNarrativeContext();
        
        const messages = [
            {
                role: 'system',
                content: `Generate a DIFFERENT version of the current scene. Vary the events, dialogue, and choices significantly.
                
Context: ${context}

Structure:
[Environmental Description]
[Character Positioning]
[Dialogue]
[Available Actions] - 4 completely different options
[Scene Hook]`
            },
            {
                role: 'user',
                content: 'Generate an alternative version of this scene.'
            }
        ];
        
        try {
            const response = await this.callGPT(messages, 0.95, 1000);
            
            this.removeLastMessage();
            this.displayNarrativeResponse(response);
            
        } catch (error) {
            this.removeLastMessage();
            this.addMessage('system', `Error: ${error.message}`);
        }
        
        this.isProcessing = false;
    }
    
    // ============================================
    // CONTEXT MANAGEMENT
    // ============================================
    
    buildNarrativeContext() {
        if (!this.currentStory || !this.currentStory.character) return '';
        
        const char = this.currentStory.character;
        const recentMessages = this.messageHistory.slice(-20); // Last 20 messages
        
        let context = `Character: ${char.name} the ${char.class}\n`;
        context += `Traits: ${char.personality}, ${char.alignment}\n`;
        context += `Loves: ${char.loves}, Hates: ${char.hates}\n\n`;
        
        // Add recent narrative events
        const narrativeEvents = recentMessages
            .filter(msg => msg.role === 'assistant' && msg.content.includes('narrative-content'))
            .slice(-5); // Last 5 scenes
            
        if (narrativeEvents.length > 0) {
            context += 'Recent Events:\n';
            narrativeEvents.forEach((event, i) => {
                const parsed = this.parseNarrativeResponse(event.content);
                if (parsed.hook) {
                    context += `- Scene ${i + 1}: ${parsed.hook.substring(0, 100)}...\n`;
                }
            });
        }
        
        // Add party members
        if (this.partyMembers.length > 0) {
            context += '\nParty Members:\n';
            this.partyMembers.forEach(member => {
                context += `- ${member.name} (${member.class}): ${member.status}\n`;
            });
        }
        
        return context;
    }
    
    // ============================================
    // MESSAGE MANAGEMENT
    // ============================================
    
    addMessage(role, content) {
        const message = {
            id: Date.now(),
            role: role,
            content: content,
            timestamp: new Date().toISOString()
        };
        
        this.messageHistory.push(message);
        this.saveToStorage(this.STORAGE_KEYS.MESSAGE_HISTORY, this.messageHistory);
        
        // Add to UI
        this.appendMessageToUI(message);
        
        // Scroll to bottom
        this.scrollToBottom();
    }
    
    appendMessageToUI(message) {
        const container = document.getElementById('chat-messages');
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${message.role}`;
        messageDiv.dataset.messageId = message.id;
        
        const avatar = message.role === 'user' ? 'You' : 'VS';
        const roleLabel = message.role === 'user' ? 'You' : 'Virtue Seekers';
        
        messageDiv.innerHTML = `
            <div class="message-header">
                <div class="message-avatar">${avatar}</div>
                <div class="message-role">${roleLabel}</div>
            </div>
            <div class="message-content">${message.content}</div>
        `;
        
        container.appendChild(messageDiv);
    }
    
    removeLastMessage() {
        this.messageHistory.pop();
        const messages = document.querySelectorAll('.message');
        if (messages.length > 0) {
            messages[messages.length - 1].remove();
        }
    }
    
    displayMessageHistory() {
        const container = document.getElementById('chat-messages');
        container.innerHTML = '';
        
        this.messageHistory.forEach(message => {
            this.appendMessageToUI(message);
        });
        
        this.scrollToBottom();
    }
    
    clearChat() {
        this.messageHistory = [];
        document.getElementById('chat-messages').innerHTML = '';
    }
    
    scrollToBottom() {
        const container = document.getElementById('chat-container');
        setTimeout(() => {
            container.scrollTop = container.scrollHeight;
        }, 100);
    }
    
    // ============================================
    // MENU FUNCTIONS
    // ============================================
    
    showMenu() {
        document.getElementById('menu-modal').classList.remove('hidden');
    }
    
    hideMenu() {
        document.getElementById('menu-modal').classList.add('hidden');
    }
    
    toggleMenu() {
        const menu = document.getElementById('menu-modal');
        menu.classList.toggle('hidden');
    }
    
    showCharacterSheet() {
        if (!this.currentStory || !this.currentStory.character) {
            alert('No character created yet');
            return;
        }
        
        const char = this.currentStory.character;
        
        const sheetHTML = `
            <div class="character-sheet">
                <h3 style="margin-bottom: 20px;">${char.name}'s Character Sheet</h3>
                
                <div class="character-stat-grid">
                    <div class="stat-group">
                        <div class="stat-label">Class</div>
                        <div class="stat-value">${char.class}</div>
                        <div class="stat-value" style="font-size: 12px; color: var(--text-secondary);">${char.classDescription}</div>
                    </div>
                    
                    <div class="stat-group">
                        <div class="stat-label">Traits</div>
                        <div class="stat-value">Gender: ${char.gender}</div>
                        <div class="stat-value">Alignment: ${char.alignment}</div>
                        <div class="stat-value">Personality: ${char.personality}</div>
                    </div>
                    
                    <div class="stat-group">
                        <div class="stat-label">Equipment</div>
                        <ul class="stat-list">
                            <li>Armor: Starting gear</li>
                            <li>Weapon: Class default</li>
                            <li>Accessories: None</li>
                        </ul>
                    </div>
                    
                    <div class="stat-group">
                        <div class="stat-label">Skills & Abilities</div>
                        <ul class="stat-list">
                            <li>Class abilities developing...</li>
                        </ul>
                    </div>
                    
                    <div class="stat-group">
                        <div class="stat-label">Current Objectives</div>
                        <ul class="stat-list">
                            <li>Discover your purpose</li>
                            <li>Explore the world</li>
                        </ul>
                    </div>
                    
                    <div class="stat-group">
                        <div class="stat-label">Personal Details</div>
                        <div class="stat-value">Loves: ${char.loves}</div>
                        <div class="stat-value">Hates: ${char.hates}</div>
                    </div>
                </div>
            </div>
        `;
        
        // Replace menu content temporarily
        const menuContent = document.querySelector('.menu-content');
        const originalContent = menuContent.innerHTML;
        
        menuContent.innerHTML = `
            <div class="menu-header">
                <h2 class="menu-title">Character Sheet</h2>
                <button class="close-button" onclick="app.hideMenu()">×</button>
            </div>
            ${sheetHTML}
            <button class="menu-action" onclick="app.restoreMenu()" style="margin-top: 20px;">← Back to Menu</button>
        `;
    }
    
    showQuestJournal() {
        const questHTML = this.questJournal.length > 0 
            ? this.questJournal.map((quest, index) => `
                <div class="stat-group" style="position: relative;">
                    <button class="close-button" onclick="app.removeQuest(${index})" style="position: absolute; right: 0; top: 0; width: 24px; height: 24px; font-size: 16px;">×</button>
                    <div class="stat-label">${quest.title}</div>
                    <div class="stat-value">${quest.description}</div>
                    <div class="stat-value" style="font-size: 12px; color: var(--text-tertiary);">Status: ${quest.status}</div>
                    ${quest.objectives ? `
                        <ul class="stat-list">
                            ${quest.objectives.map(obj => `<li>${obj.completed ? '✓' : '○'} ${obj.text}</li>`).join('')}
                        </ul>
                    ` : ''}
                </div>
            `).join('')
            : '<p style="color: var(--text-secondary);">No active quests. Your journey awaits...</p>';
            
        const menuContent = document.querySelector('.menu-content');
        menuContent.innerHTML = `
            <div class="menu-header">
                <h2 class="menu-title">Quest Journal</h2>
                <button class="close-button" onclick="app.hideMenu()">×</button>
            </div>
            <div class="character-sheet">
                ${questHTML}
            </div>
            <button class="menu-action" onclick="app.restoreMenu()" style="margin-top: 20px;">← Back to Menu</button>
        `;
    }
    
    showRelationships() {
        const relationshipHTML = Object.keys(this.relationships).length > 0 
            ? Object.entries(this.relationships).map(([character, data]) => `
                <div class="stat-group" style="position: relative;">
                    <button class="close-button" onclick="app.removeRelationship('${character}')" style="position: absolute; right: 0; top: 0; width: 24px; height: 24px; font-size: 16px;">×</button>
                    <div class="stat-label">${character.toUpperCase()}</div>
                    <div class="stat-value">Status: ${data.status || 'Acquaintance'}</div>
                    <div class="stat-value">Relationship: ${data.relationship || 'Neutral'}</div>
                    ${data.notes ? `<div class="stat-value" style="font-size: 13px; color: var(--text-secondary);">${data.notes}</div>` : ''}
                    ${data.firstMet ? `<div class="stat-value" style="font-size: 12px; color: var(--text-tertiary);">First met: Scene ${data.firstMet}</div>` : ''}
                </div>
            `).join('')
            : '<p style="color: var(--text-secondary);">No relationships tracked yet. Meet some characters!</p>';
            
        const menuContent = document.querySelector('.menu-content');
        menuContent.innerHTML = `
            <div class="menu-header">
                <h2 class="menu-title">Relationship Tracker</h2>
                <button class="close-button" onclick="app.hideMenu()">×</button>
            </div>
            <div class="character-sheet">
                ${relationshipHTML}
            </div>
            <button class="menu-action" onclick="app.restoreMenu()" style="margin-top: 20px;">← Back to Menu</button>
        `;
    }
    
    // Quest Management
    addQuest(title, description, objectives = []) {
        const quest = {
            title,
            description,
            status: 'Active',
            objectives: objectives.map(obj => ({ text: obj, completed: false })),
            addedAt: this.currentStory?.sceneCount || 0
        };
        
        this.questJournal.push(quest);
        this.saveToStorage(this.STORAGE_KEYS.QUEST_JOURNAL, this.questJournal);
    }
    
    updateQuest(title, updates) {
        const questIndex = this.questJournal.findIndex(q => q.title === title);
        if (questIndex !== -1) {
            this.questJournal[questIndex] = { ...this.questJournal[questIndex], ...updates };
            this.saveToStorage(this.STORAGE_KEYS.QUEST_JOURNAL, this.questJournal);
        }
    }
    
    removeQuest(index) {
        this.questJournal.splice(index, 1);
        this.saveToStorage(this.STORAGE_KEYS.QUEST_JOURNAL, this.questJournal);
        this.showQuestJournal(); // Refresh the view
    }
    
    // Relationship Management
    addRelationship(character, status = 'Acquaintance', relationship = 'Neutral', notes = '') {
        this.relationships[character.toLowerCase()] = {
            status,
            relationship,
            notes,
            firstMet: this.currentStory?.sceneCount || 0,
            lastInteraction: this.currentStory?.sceneCount || 0
        };
        
        this.saveToStorage(this.STORAGE_KEYS.RELATIONSHIPS, this.relationships);
    }
    
    updateRelationship(character, updates) {
        const key = character.toLowerCase();
        if (this.relationships[key]) {
            this.relationships[key] = { ...this.relationships[key], ...updates };
            this.relationships[key].lastInteraction = this.currentStory?.sceneCount || 0;
            this.saveToStorage(this.STORAGE_KEYS.RELATIONSHIPS, this.relationships);
        } else {
            // Create new relationship if it doesn't exist
            this.addRelationship(character, updates.status, updates.relationship, updates.notes);
        }
    }
    
    removeRelationship(character) {
        delete this.relationships[character.toLowerCase()];
        this.saveToStorage(this.STORAGE_KEYS.RELATIONSHIPS, this.relationships);
        this.showRelationships(); // Refresh the view
    }
    
    // Track NPCs from dialogue
    trackNPCFromDialogue(speaker) {
        const key = speaker.toLowerCase();
        if (!this.relationships[key] && speaker !== this.currentStory?.character?.name) {
            this.addRelationship(speaker);
        }
    }
    
    restoreMenu() {
        // Restore original menu
        this.hideMenu();
        setTimeout(() => this.showMenu(), 100);
    }
    
    showPartyMembers() {
        const partyHTML = this.partyMembers.length > 0 
            ? this.partyMembers.map(member => `
                <div class="stat-group">
                    <div class="stat-label">${member.name}</div>
                    <div class="stat-value">Class: ${member.class}</div>
                    <div class="stat-value">Status: ${member.status}</div>
                </div>
            `).join('')
            : '<p style="color: var(--text-secondary);">No party members yet. You adventure alone.</p>';
            
        const menuContent = document.querySelector('.menu-content');
        menuContent.innerHTML = `
            <div class="menu-header">
                <h2 class="menu-title">Party Members</h2>
                <button class="close-button" onclick="app.hideMenu()">×</button>
            </div>
            <div class="character-sheet">
                ${partyHTML}
            </div>
            <button class="menu-action" onclick="app.restoreMenu()" style="margin-top: 20px;">← Back to Menu</button>
        `;
    }
    
    async exportStory() {
        const storyData = {
            character: this.currentStory,
            messages: this.messageHistory,
            partyMembers: this.partyMembers,
            exportDate: new Date().toISOString()
        };
        
        const blob = new Blob([JSON.stringify(storyData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `virtue-seekers-${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
        
        this.hideMenu();
        this.addMessage('system', 'Story exported successfully!');
    }
    
    showStats() {
        const stats = {
            scenes: this.currentStory?.sceneCount || 0,
            messages: this.messageHistory.length,
            words: this.messageHistory.reduce((acc, msg) => acc + msg.content.split(' ').length, 0),
            partySize: this.partyMembers.length + 1
        };
        
        const menuContent = document.querySelector('.menu-content');
        menuContent.innerHTML = `
            <div class="menu-header">
                <h2 class="menu-title">Story Statistics</h2>
                <button class="close-button" onclick="app.hideMenu()">×</button>
            </div>
            <div class="character-sheet">
                <div class="stat-group">
                    <div class="stat-label">Scenes Completed</div>
                    <div class="stat-value">${stats.scenes}</div>
                </div>
                <div class="stat-group">
                    <div class="stat-label">Total Messages</div>
                    <div class="stat-value">${stats.messages}</div>
                </div>
                <div class="stat-group">
                    <div class="stat-label">Words Written</div>
                    <div class="stat-value">${stats.words.toLocaleString()}</div>
                </div>
                <div class="stat-group">
                    <div class="stat-label">Party Size</div>
                    <div class="stat-value">${stats.partySize} adventurer${stats.partySize > 1 ? 's' : ''}</div>
                </div>
            </div>
            <button class="menu-action" onclick="app.restoreMenu()" style="margin-top: 20px;">← Back to Menu</button>
        `;
    }
    
    changeApiKey() {
        if (confirm('Change API key? This will not affect your current story.')) {
            this.hideMenu();
            this.showApiKeyPrompt();
        }
    }
    
    clearData() {
        if (confirm('Start a new story? This will clear all current progress.')) {
            this.clearChat();
            this.currentStory = null;
            this.partyMembers = [];
            this.questJournal = [];
            this.relationships = {};
            this.saveToStorage(this.STORAGE_KEYS.MESSAGE_HISTORY, []);
            this.saveToStorage(this.STORAGE_KEYS.CURRENT_STORY, null);
            this.saveToStorage(this.STORAGE_KEYS.PARTY_MEMBERS, []);
            this.saveToStorage(this.STORAGE_KEYS.QUEST_JOURNAL, []);
            this.saveToStorage(this.STORAGE_KEYS.RELATIONSHIPS, {});
            this.hideMenu();
            this.startNewStory();
        }
    }
    
    // ============================================
    // GPT API
    // ============================================
    
    async callGPT(messages, temperature = 0.8, maxTokens = 1000) {
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${this.apiKey}`
            },
            body: JSON.stringify({
                model: 'gpt-4.1-mini',
                messages: messages,
                temperature: temperature,
                max_tokens: maxTokens,
                presence_penalty: 0.6,
                frequency_penalty: 0.3
            })
        });
        
        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error?.message || 'API request failed');
        }
        
        const data = await response.json();
        return data.choices[0].message.content;
    }
}

// ============================================
// INITIALIZE
// ============================================

let app = null;

document.addEventListener('DOMContentLoaded', () => {
    app = new VirtueSeekers();
    window.app = app;
    app.initialize();
});
    </script>
</body>
</html>