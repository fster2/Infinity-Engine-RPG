<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    <title>Infinity Engine RPG</title>
    
    <!-- Modern Font Stack -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <style>
        /* ================================
           2025 ULTRA-MODERN DESIGN SYSTEM
           ================================ */
        :root {
            /* Modern Dark Theme */
            --bg-primary: #000000;
            --bg-secondary: #0a0a0a;
            --bg-tertiary: #141414;
            --bg-elevated: #1c1c1c;
            
            /* Text Hierarchy */
            --text-primary: #ffffff;
            --text-secondary: #a0a0a0;
            --text-tertiary: #666666;
            
            /* Accent System */
            --accent-primary: #0a84ff;
            --accent-secondary: #5e5ce6;
            --accent-success: #30d158;
            --accent-warning: #ff9f0a;
            --accent-danger: #ff453a;
            
            /* Surfaces */
            --surface-primary: rgba(255, 255, 255, 0.05);
            --surface-secondary: rgba(255, 255, 255, 0.08);
            --surface-tertiary: rgba(255, 255, 255, 0.11);
            
            /* Borders */
            --border-subtle: rgba(255, 255, 255, 0.06);
            --border-medium: rgba(255, 255, 255, 0.12);
            --border-strong: rgba(255, 255, 255, 0.18);
            
            /* Effects */
            --blur-amount: 20px;
            --shadow-elevation-low: 0 2px 8px rgba(0, 0, 0, 0.3);
            --shadow-elevation-medium: 0 8px 24px rgba(0, 0, 0, 0.4);
            --shadow-elevation-high: 0 16px 48px rgba(0, 0, 0, 0.5);
            
            /* Animations */
            --ease-out-expo: cubic-bezier(0.16, 1, 0.3, 1);
            --ease-in-out-expo: cubic-bezier(0.87, 0, 0.13, 1);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Base Styles */
        body {
            background: var(--bg-primary);
            color: var(--text-primary);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            font-size: 16px;
            line-height: 1.6;
            min-height: 100vh;
            overflow-x: hidden;
            overscroll-behavior: none;
        }

        /* Smooth Scrolling */
        html {
            scroll-behavior: smooth;
        }

        /* Main App Container */
        #app {
            min-height: 100vh;
            position: relative;
            padding-bottom: env(safe-area-inset-bottom);
        }

        /* Modern App Header */
        .app-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(var(--blur-amount));
            -webkit-backdrop-filter: blur(var(--blur-amount));
            border-bottom: 1px solid var(--border-subtle);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
        }

        .app-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .scene-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background: var(--surface-primary);
            border-radius: 20px;
            font-size: 13px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .scene-dot {
            width: 6px;
            height: 6px;
            background: var(--accent-primary);
            border-radius: 50%;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 1; }
        }

        /* Content Container */
        .content-container {
            padding: 80px 20px 120px;
            max-width: 800px;
            margin: 0 auto;
        }

        /* Loading State */
        .loading-container {
            position: fixed;
            inset: 0;
            background: var(--bg-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .loading-content {
            text-align: center;
        }

        .loading-spinner {
            width: 48px;
            height: 48px;
            border: 3px solid var(--surface-secondary);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 14px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        /* Narrative Display */
        .narrative-container {
            margin-bottom: 32px;
            animation: fadeInUp 0.6s var(--ease-out-expo);
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .narrative-section {
            background: var(--surface-primary);
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 16px;
            border: 1px solid var(--border-subtle);
            position: relative;
            overflow: hidden;
        }

        .narrative-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, 
                transparent,
                var(--accent-primary),
                transparent
            );
            opacity: 0.5;
        }

        /* Scene Text Styling */
        .scene-text {
            font-size: 17px;
            line-height: 1.8;
            color: var(--text-primary);
            margin-bottom: 20px;
        }

        .scene-text p {
            margin-bottom: 16px;
        }

        .scene-text p:last-child {
            margin-bottom: 0;
        }

        /* Environmental Description */
        .environment-section {
            padding-left: 16px;
            border-left: 2px solid var(--accent-secondary);
            margin-bottom: 24px;
            font-style: italic;
            color: var(--text-secondary);
        }

        /* Character Dialogue */
        .dialogue-container {
            margin: 24px 0;
        }

        .dialogue-line {
            margin-bottom: 20px;
            padding: 16px;
            background: var(--surface-secondary);
            border-radius: 12px;
            position: relative;
        }

        .speaker-name {
            font-weight: 600;
            color: var(--accent-primary);
            margin-bottom: 4px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .speaker-tone {
            font-size: 13px;
            color: var(--text-tertiary);
            font-style: italic;
            margin-bottom: 8px;
        }

        .dialogue-text {
            font-size: 16px;
            line-height: 1.6;
            color: var(--text-primary);
        }

        /* Choice System */
        .choices-container {
            margin: 32px 0;
        }

        .choice-card {
            background: var(--surface-primary);
            border: 1px solid var(--border-subtle);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.2s var(--ease-out-expo);
            position: relative;
            overflow: hidden;
        }

        .choice-card::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, 
                transparent 0%, 
                var(--accent-primary) 100%
            );
            opacity: 0;
            transition: opacity 0.3s;
        }

        .choice-card:hover {
            transform: translateY(-2px);
            border-color: var(--accent-primary);
            box-shadow: var(--shadow-elevation-low);
        }

        .choice-card:hover::before {
            opacity: 0.05;
        }

        .choice-card:active {
            transform: translateY(0);
        }

        .choice-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            background: var(--accent-primary);
            color: var(--bg-primary);
            border-radius: 50%;
            font-size: 12px;
            font-weight: 600;
            margin-right: 12px;
        }

        .choice-text {
            font-size: 16px;
            line-height: 1.5;
            color: var(--text-primary);
        }

        /* Custom Action Input */
        .custom-action-container {
            background: var(--bg-elevated);
            border-radius: 20px;
            padding: 24px;
            margin: 32px 0;
            border: 1px solid var(--border-subtle);
        }

        .custom-action-label {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }

        .custom-action-form {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
        }

        .custom-input {
            flex: 1;
            padding: 14px 18px;
            background: var(--surface-primary);
            border: 1px solid var(--border-medium);
            border-radius: 12px;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 16px;
            transition: all 0.2s;
        }

        .custom-input:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(10, 132, 255, 0.1);
        }

        .custom-input::placeholder {
            color: var(--text-tertiary);
        }

        .action-button {
            padding: 14px 24px;
            background: var(--accent-primary);
            color: white;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            font-size: 15px;
            cursor: pointer;
            transition: all 0.2s var(--ease-out-expo);
            white-space: nowrap;
        }

        .action-button:hover {
            background: var(--accent-secondary);
            transform: scale(1.02);
        }

        .action-button:active {
            transform: scale(0.98);
        }

        /* Regenerate Button */
        .regenerate-button {
            width: 100%;
            padding: 14px;
            background: var(--surface-secondary);
            border: 1px solid var(--border-medium);
            border-radius: 12px;
            color: var(--text-secondary);
            font-weight: 500;
            font-size: 15px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .regenerate-button:hover {
            background: var(--surface-tertiary);
            color: var(--text-primary);
            border-color: var(--accent-primary);
        }

        .regenerate-icon {
            font-size: 18px;
        }

        /* Messages/Toasts */
        .toast {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            padding: 16px 24px;
            background: var(--bg-elevated);
            border: 1px solid var(--border-medium);
            border-radius: 12px;
            font-size: 14px;
            font-weight: 500;
            z-index: 2000;
            animation: slideDown 0.3s var(--ease-out-expo);
            box-shadow: var(--shadow-elevation-medium);
            backdrop-filter: blur(var(--blur-amount));
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translate(-50%, -20px);
            }
            to {
                opacity: 1;
                transform: translate(-50%, 0);
            }
        }

        .toast.error {
            border-color: var(--accent-danger);
            color: var(--accent-danger);
        }

        .toast.success {
            border-color: var(--accent-success);
            color: var(--accent-success);
        }

        /* Character Creation */
        .creation-container {
            max-width: 600px;
            margin: 0 auto;
            padding: 32px 20px;
        }

        .creation-header {
            text-align: center;
            margin-bottom: 40px;
        }

        .creation-title {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 12px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .creation-subtitle {
            font-size: 16px;
            color: var(--text-secondary);
        }

        .creation-card {
            background: var(--surface-primary);
            border: 1px solid var(--border-subtle);
            border-radius: 20px;
            padding: 32px;
            margin-bottom: 24px;
        }

        .input-group {
            margin-bottom: 24px;
        }

        .input-label {
            display: block;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .creation-input {
            width: 100%;
            padding: 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-medium);
            border-radius: 12px;
            color: var(--text-primary);
            font-size: 16px;
            transition: all 0.2s;
        }

        .creation-input:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(10, 132, 255, 0.1);
        }

        /* Class Selection Grid */
        .class-grid {
            display: grid;
            gap: 12px;
            margin-bottom: 24px;
        }

        .class-card {
            padding: 20px;
            background: var(--surface-secondary);
            border: 2px solid transparent;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.2s var(--ease-out-expo);
        }

        .class-card:hover {
            border-color: var(--accent-primary);
            transform: translateY(-2px);
            box-shadow: var(--shadow-elevation-low);
        }

        .class-card.selected {
            border-color: var(--accent-primary);
            background: var(--surface-tertiary);
        }

        .class-name {
            font-weight: 600;
            font-size: 18px;
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        .class-description {
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        /* Continue Button */
        .continue-button {
            width: 100%;
            padding: 18px;
            background: var(--accent-primary);
            color: white;
            border: none;
            border-radius: 16px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s var(--ease-out-expo);
        }

        .continue-button:hover {
            background: var(--accent-secondary);
            transform: scale(1.02);
        }

        /* Processing State */
        .processing-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(8px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9998;
        }

        .processing-card {
            background: var(--bg-elevated);
            border: 1px solid var(--border-medium);
            border-radius: 20px;
            padding: 32px;
            text-align: center;
            box-shadow: var(--shadow-elevation-high);
        }

        .processing-spinner {
            width: 56px;
            height: 56px;
            border: 3px solid var(--surface-tertiary);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin: 0 auto 20px;
        }

        .processing-text {
            font-size: 16px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        /* API Key Prompt */
        .api-key-container {
            background: var(--surface-primary);
            border: 1px solid var(--border-subtle);
            border-radius: 20px;
            padding: 32px;
            max-width: 500px;
            margin: 0 auto;
        }

        .api-key-header {
            text-align: center;
            margin-bottom: 32px;
        }

        .api-key-title {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 12px;
        }

        .api-key-description {
            font-size: 16px;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        .api-key-link {
            color: var(--accent-primary);
            text-decoration: none;
            font-weight: 500;
        }

        .api-key-link:hover {
            text-decoration: underline;
        }

        /* Mobile Optimizations */
        @media (max-width: 600px) {
            .content-container {
                padding: 70px 16px 100px;
            }
            
            .narrative-section {
                padding: 20px;
            }
            
            .scene-text {
                font-size: 16px;
            }
            
            .creation-card {
                padding: 24px;
            }
        }

        /* Utility */
        .hidden {
            display: none !important;
        }

        /* Disabled State */
        button:disabled,
        input:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <!-- Loading State -->
    <div id="loading-container" class="loading-container">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <div class="loading-text">Initializing Infinity Engine...</div>
        </div>
    </div>

    <!-- Main App -->
    <div id="app" class="hidden">
        <!-- Fixed Header -->
        <header class="app-header">
            <div class="app-title">Infinity Engine</div>
            <div class="scene-indicator">
                <div class="scene-dot"></div>
                <span id="scene-counter">Scene 1</span>
            </div>
        </header>

        <!-- Content -->
        <div class="content-container" id="content-container">
            <!-- Dynamic content inserted here -->
        </div>
    </div>

    <script>
// ============================================
// INFINITY ENGINE - 2025 EDITION
// ============================================

class InfinityEngine {
    constructor() {
        this.apiKey = null;
        this.currentStory = null;
        this.currentScene = null;
        this.isProcessing = false;
        this.lastContext = null;
        
        // Storage keys
        this.STORAGE_PREFIX = 'infinity_';
        this.STORAGE_KEYS = {
            API_KEY: 'api_key',
            CURRENT_STORY: 'current_story',
            SCENE_HISTORY: 'scene_history',
            WORLD_STATE: 'world_state'
        };
        
        // Initialize on construction
        this.initialize();
    }
    
    async initialize() {
        try {
            // Check for existing API key
            this.apiKey = this.getFromStorage(this.STORAGE_KEYS.API_KEY);
            
            if (!this.apiKey) {
                this.hideLoading();
                this.showApiKeyPrompt();
                return;
            }
            
            // Check for existing story
            this.currentStory = this.getFromStorage(this.STORAGE_KEYS.CURRENT_STORY);
            
            if (this.currentStory) {
                await this.resumeStory();
            } else {
                await this.startNewStory();
            }
            
            this.hideLoading();
            
        } catch (error) {
            console.error('Initialization failed:', error);
            this.showError('Failed to initialize. Please refresh the page.');
        }
    }
    
    // ============================================
    // STORAGE MANAGEMENT
    // ============================================
    
    saveToStorage(key, value) {
        try {
            localStorage.setItem(this.STORAGE_PREFIX + key, JSON.stringify(value));
        } catch (e) {
            // Fallback for sandboxed environments
            if (!window._memoryFallback) window._memoryFallback = {};
            window._memoryFallback[this.STORAGE_PREFIX + key] = value;
            console.log('Using memory fallback due to sandbox restrictions');
        }
    }
    
    getFromStorage(key) {
        try {
            const item = localStorage.getItem(this.STORAGE_PREFIX + key);
            return item ? JSON.parse(item) : null;
        } catch (e) {
            // Fallback for sandboxed environments
            if (window._memoryFallback && window._memoryFallback[this.STORAGE_PREFIX + key]) {
                return window._memoryFallback[this.STORAGE_PREFIX + key];
            }
            console.log('Using memory fallback due to sandbox restrictions');
            return null;
        }
    }
    
    // ============================================
    // API KEY MANAGEMENT
    // ============================================
    
    showApiKeyPrompt() {
        const content = document.getElementById('content-container');
        content.innerHTML = `
            <div class="api-key-container">
                <div class="api-key-header">
                    <h1 class="api-key-title">Welcome to Infinity Engine</h1>
                    <p class="api-key-description">
                        To power your infinite narrative, you'll need an OpenAI API key.
                        Your key is stored locally and never shared.
                    </p>
                </div>
                <div class="input-group">
                    <label class="input-label">OpenAI API Key</label>
                    <input type="password" 
                           id="api-key-input" 
                           class="creation-input" 
                           placeholder="sk-..." 
                           autocomplete="off">
                </div>
                <button class="continue-button" onclick="app.submitApiKey()">
                    Activate Infinity Engine
                </button>
                <p style="text-align: center; margin-top: 24px;">
                    <a href="https://platform.openai.com/api-keys" 
                       target="_blank" 
                       class="api-key-link">
                        Get your API key from OpenAI →
                    </a>
                </p>
            </div>
        `;
        
        // Add enter key support
        const input = document.getElementById('api-key-input');
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') this.submitApiKey();
        });
        
        setTimeout(() => input.focus(), 100);
    }
    
    async submitApiKey() {
        const input = document.getElementById('api-key-input');
        const apiKey = input.value.trim();
        
        if (!apiKey || !apiKey.startsWith('sk-')) {
            this.showError('Please enter a valid OpenAI API key');
            return;
        }
        
        this.apiKey = apiKey;
        this.saveToStorage(this.STORAGE_KEYS.API_KEY, apiKey);
        await this.startNewStory();
    }
    
    // ============================================
    // STORY MANAGEMENT
    // ============================================
    
    async startNewStory() {
        const character = await this.showCharacterCreation();
        
        this.currentStory = {
            id: Date.now(),
            character: character,
            sceneCount: 0,
            created: new Date().toISOString(),
            worldState: {}
        };
        
        this.saveToStorage(this.STORAGE_KEYS.CURRENT_STORY, this.currentStory);
        
        // Generate opening scene
        await this.generateOpeningScene();
    }
    
    async resumeStory() {
        // Load scene history
        const sceneHistory = this.getFromStorage(this.STORAGE_KEYS.SCENE_HISTORY) || [];
        
        if (sceneHistory.length > 0) {
            const lastScene = sceneHistory[sceneHistory.length - 1];
            this.currentScene = lastScene;
            this.displayScene(lastScene);
            this.updateSceneCounter();
        } else {
            await this.generateOpeningScene();
        }
    }
    
    // ============================================
    // CHARACTER CREATION
    // ============================================
    
    async showCharacterCreation() {
        return new Promise(async (resolve) => {
            const content = document.getElementById('content-container');
            
            // Step 1: Name
            content.innerHTML = `
                <div class="creation-container">
                    <div class="creation-header">
                        <h1 class="creation-title">Create Your Character</h1>
                        <p class="creation-subtitle">Begin your infinite journey</p>
                    </div>
                    <div class="creation-card">
                        <div class="input-group">
                            <label class="input-label">Character Name</label>
                            <input type="text" 
                                   id="character-name" 
                                   class="creation-input" 
                                   placeholder="Enter your character's name..."
                                   maxlength="30">
                        </div>
                        <button class="continue-button" id="continue-name">
                            Continue →
                        </button>
                    </div>
                </div>
            `;
            
            const nameInput = document.getElementById('character-name');
            const continueBtn = document.getElementById('continue-name');
            
            nameInput.focus();
            
            const proceedToClass = async () => {
                const name = nameInput.value.trim();
                if (!name) {
                    this.showError('Please enter a character name');
                    return;
                }
                
                // Step 2: Class Selection
                this.showProcessing('Discovering unique paths...');
                const classes = await this.generateClasses();
                this.hideProcessing();
                
                content.innerHTML = `
                    <div class="creation-container">
                        <div class="creation-header">
                            <h1 class="creation-title">Choose Your Path</h1>
                            <p class="creation-subtitle">Select your class, ${name}</p>
                        </div>
                        <div class="creation-card">
                            <div class="class-grid" id="class-grid">
                                ${classes.map((cls, i) => `
                                    <div class="class-card" data-class="${cls.name}" data-index="${i}">
                                        <div class="class-name">${cls.name}</div>
                                        <div class="class-description">${cls.description}</div>
                                    </div>
                                `).join('')}
                            </div>
                            <button class="regenerate-button" onclick="app.regenerateClasses()">
                                <span class="regenerate-icon">↻</span>
                                Show Different Classes
                            </button>
                        </div>
                    </div>
                `;
                
                // Class selection logic
                let selectedClass = null;
                document.querySelectorAll('.class-card').forEach(card => {
                    card.addEventListener('click', () => {
                        document.querySelectorAll('.class-card').forEach(c => 
                            c.classList.remove('selected')
                        );
                        card.classList.add('selected');
                        selectedClass = classes[card.dataset.index];
                        
                        // Auto-proceed after selection
                        setTimeout(() => {
                            resolve({
                                name: name,
                                class: selectedClass.name,
                                classDescription: selectedClass.description
                            });
                        }, 300);
                    });
                });
                
                // Store classes for regeneration
                window._currentClasses = classes;
                window._characterName = name;
                window._resolveCharacter = resolve;
            };
            
            continueBtn.addEventListener('click', proceedToClass);
            nameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') proceedToClass();
            });
        });
    }
    
    async regenerateClasses() {
        this.showProcessing('Discovering new paths...');
        const classes = await this.generateClasses();
        this.hideProcessing();
        
        const grid = document.getElementById('class-grid');
        grid.innerHTML = classes.map((cls, i) => `
            <div class="class-card" data-class="${cls.name}" data-index="${i}">
                <div class="class-name">${cls.name}</div>
                <div class="class-description">${cls.description}</div>
            </div>
        `).join('');
        
        // Rebind click handlers
        let selectedClass = null;
        document.querySelectorAll('.class-card').forEach(card => {
            card.addEventListener('click', () => {
                document.querySelectorAll('.class-card').forEach(c => 
                    c.classList.remove('selected')
                );
                card.classList.add('selected');
                selectedClass = classes[card.dataset.index];
                
                setTimeout(() => {
                    window._resolveCharacter({
                        name: window._characterName,
                        class: selectedClass.name,
                        classDescription: selectedClass.description
                    });
                }, 300);
            });
        });
    }
    
    // ============================================
    // NARRATIVE GENERATION
    // ============================================
    
    async generateClasses() {
        try {
            const response = await this.callGPT([
                {
                    role: 'system',
                    content: 'Generate 6 unique fantasy RPG classes. Each should be creative and unusual, not standard fantasy tropes. Return as JSON array with "name" and "description" fields. Keep descriptions to one compelling sentence.'
                },
                {
                    role: 'user',
                    content: 'Generate 6 unique character classes for a narrative RPG. Be creative and avoid clichés.'
                }
            ], 0.9, 400);
            
            // Parse JSON from response
            const jsonMatch = response.match(/\[[\s\S]*\]/);
            if (jsonMatch) {
                return JSON.parse(jsonMatch[0]);
            }
        } catch (error) {
            console.error('Class generation failed:', error);
        }
        
        // Fallback classes
        return [
            { name: "Dreamwright", description: "Architects who build reality from the fragments of sleeping minds" },
            { name: "Voidbinder", description: "Those who forge contracts with the hungry spaces between stars" },
            { name: "Thornkeeper", description: "Guardians who cultivate gardens of living memory and painful beauty" },
            { name: "Echowalker", description: "Wanderers who step through the reverberations of past and future" },
            { name: "Glassweaver", description: "Artisans who spin fate itself from threads of crystallized time" },
            { name: "Shadowscribe", description: "Writers whose words cast living darkness across reality" }
        ];
    }
    
    async generateOpeningScene() {
        this.showProcessing('Weaving your story...');
        
        const character = this.currentStory.character;
        
        const messages = [
            {
                role: 'system',
                content: `You are a masterful storyteller creating an immersive fantasy narrative. 
Write rich, detailed scenes with multiple paragraphs.

IMPORTANT: Write 3-5 substantial paragraphs for each section.

Structure your response as follows:

[Setting]
Multiple paragraphs describing the environment with rich sensory details. Include sounds, smells, textures, lighting, and magical elements.

[Action]
Multiple paragraphs showing what happens. SHOW the player's actions in detail, don't just skip to results. Describe movements, reactions, and consequences.

[Characters]
Describe any NPCs present, their appearance, mannerisms, and current actions.

[Dialogue]
Format: CharacterName: (emotion) "What they say."
Make dialogue natural and revealing of character.

[Options]
Present exactly 4 distinct choices that lead in different directions. Make each choice meaningful and different from the others. NEVER repeat similar options.

[Hook]
A compelling cliffhanger or revelation that creates anticipation.

Current protagonist: ${character.name} the ${character.class} (${character.classDescription})`
            },
            {
                role: 'user',
                content: `Begin an epic narrative. ${character.name} the ${character.class} awakens in a mysterious location. Create a rich, atmospheric opening with at least 3-4 paragraphs of description. Introduce an intriguing character who offers the first choices. Make the scene detailed and immersive.`
            }
        ];
        
        try {
            const response = await this.callGPT(messages, 0.8, 2000);
            const scene = this.parseScene(response);
            
            this.currentScene = scene;
            this.saveScene(scene);
            this.displayScene(scene);
            
        } catch (error) {
            this.showError('Failed to generate opening scene. Please check your API key.');
        }
        
        this.hideProcessing();
    }
    
    async handleChoice(choiceIndex) {
        if (this.isProcessing) return;
        
        const choice = this.currentScene.options[choiceIndex - 1];
        if (!choice) return;
        
        this.isProcessing = true;
        this.showProcessing('Continuing your story...');
        
        // Build context with memory
        const recentScenes = this.getRecentScenes(3);
        const contextSummary = this.buildContextSummary(recentScenes);
        
        const messages = [
            {
                role: 'system',
                content: `You are a masterful storyteller creating an immersive fantasy narrative. 
Write rich, detailed scenes with multiple paragraphs.

IMPORTANT: 
- Write 3-5 substantial paragraphs for each section
- SHOW the player's chosen action happening in detail
- Don't skip to the aftermath - describe the action itself
- Make each option unique - never repeat similar choices

Structure your response as follows:

[Setting]
Multiple paragraphs with rich sensory details.

[Action]
Multiple paragraphs showing EXACTLY what happens when the player takes their chosen action. Describe it step by step.

[Characters]
NPCs present and their reactions.

[Dialogue]
CharacterName: (emotion) "What they say."

[Options]
4 distinct choices that are ALL different from each other.

[Hook]
A compelling cliffhanger.

Protagonist: ${this.currentStory.character.name} the ${this.currentStory.character.class}
Recent context: ${contextSummary}`
            },
            {
                role: 'user',
                content: `The player chose: "${choice}"

IMPORTANT: Start by showing this action happening in detail. Describe ${this.currentStory.character.name} performing this exact action, then show the consequences and reactions. Write at least 3-4 paragraphs describing the action and its immediate effects before moving to the next development.`
            }
        ];
        
        try {
            const response = await this.callGPT(messages, 0.8, 2000);
            const scene = this.parseScene(response);
            
            // Check for duplicate options
            const uniqueOptions = [...new Set(scene.options)];
            if (uniqueOptions.length < scene.options.length) {
                // Regenerate if we have duplicates
                console.log('Duplicate options detected, regenerating...');
                scene.options = await this.regenerateOptions(scene);
            }
            
            this.currentScene = scene;
            this.saveScene(scene);
            this.displayScene(scene);
            
        } catch (error) {
            this.showError('Failed to continue narrative. Please try again.');
        }
        
        this.isProcessing = false;
        this.hideProcessing();
    }
    
    async handleCustomAction(action) {
        if (!action || this.isProcessing) return;
        
        this.isProcessing = true;
        this.showProcessing('Weaving your action into the story...');
        
        const recentScenes = this.getRecentScenes(3);
        const contextSummary = this.buildContextSummary(recentScenes);
        
        const messages = [
            {
                role: 'system',
                content: `You are a masterful storyteller. The player wants to take a custom action.

IMPORTANT:
- Show the action happening in detail (3-4 paragraphs minimum)
- If the action seems impossible, show the attempt and realistic consequences
- Maintain narrative consistency

Use the same structure: [Setting], [Action], [Characters], [Dialogue], [Options], [Hook]

Protagonist: ${this.currentStory.character.name} the ${this.currentStory.character.class}
Context: ${contextSummary}`
            },
            {
                role: 'user',
                content: `The player attempts to: "${action}"

Show ${this.currentStory.character.name} attempting this exact action. Describe it happening in detail over multiple paragraphs, then show the results.`
            }
        ];
        
        try {
            const response = await this.callGPT(messages, 0.8, 2000);
            const scene = this.parseScene(response);
            
            this.currentScene = scene;
            this.saveScene(scene);
            this.displayScene(scene);
            
            // Clear input
            document.getElementById('custom-action-input').value = '';
            
        } catch (error) {
            this.showError('Failed to process custom action.');
        }
        
        this.isProcessing = false;
        this.hideProcessing();
    }
    
    async regenerateScene() {
        if (this.isProcessing || !this.lastContext) return;
        
        this.isProcessing = true;
        this.showProcessing('Reweaving the narrative...');
        
        try {
            // Use higher temperature for more variation
            const response = await this.callGPT(this.lastContext, 0.9, 2000);
            const scene = this.parseScene(response);
            
            // Ensure unique options
            const uniqueOptions = [...new Set(scene.options)];
            if (uniqueOptions.length < scene.options.length) {
                scene.options = await this.regenerateOptions(scene);
            }
            
            this.currentScene = scene;
            this.displayScene(scene);
            
            this.showSuccess('Scene regenerated with new possibilities!');
            
        } catch (error) {
            this.showError('Failed to regenerate scene.');
        }
        
        this.isProcessing = false;
        this.hideProcessing();
    }
    
    async regenerateOptions(scene) {
        const messages = [
            {
                role: 'system',
                content: 'Generate 4 completely different action options for the current scene. Each must be distinct and lead in a different direction. Format as a JSON array of strings.'
            },
            {
                role: 'user',
                content: `Current scene summary: ${scene.setting}\n\nGenerate 4 unique action options. Make them diverse: perhaps one combat, one social, one exploration, one creative/unexpected.`
            }
        ];
        
        try {
            const response = await this.callGPT(messages, 0.9, 300);
            const jsonMatch = response.match(/\[[\s\S]*\]/);
            if (jsonMatch) {
                return JSON.parse(jsonMatch[0]);
            }
        } catch (error) {
            console.error('Option regeneration failed');
        }
        
        // Fallback
        return [
            "Investigate the mysterious sounds coming from the shadows",
            "Attempt to befriend the nearest character through conversation",
            "Search the area for hidden passages or useful items",
            "Use your class abilities in an unexpected way"
        ];
    }
    
    // ============================================
    // SCENE PARSING & DISPLAY
    // ============================================
    
    parseScene(text) {
        const scene = {
            setting: '',
            action: '',
            characters: '',
            dialogue: [],
            options: [],
            hook: '',
            raw: text
        };
        
        // Parse sections
        const sections = text.split(/\[([^\]]+)\]/);
        let currentSection = '';
        
        for (let i = 0; i < sections.length; i++) {
            const content = sections[i].trim();
            
            if (content.match(/^Setting$/i)) {
                currentSection = 'setting';
            } else if (content.match(/^Action$/i)) {
                currentSection = 'action';
            } else if (content.match(/^Characters?$/i)) {
                currentSection = 'characters';
            } else if (content.match(/^Dialogue$/i)) {
                currentSection = 'dialogue';
            } else if (content.match(/^Options?$/i)) {
                currentSection = 'options';
            } else if (content.match(/^Hook$/i)) {
                currentSection = 'hook';
            } else if (currentSection && content) {
                switch (currentSection) {
                    case 'setting':
                        scene.setting = content;
                        break;
                    case 'action':
                        scene.action = content;
                        break;
                    case 'characters':
                        scene.characters = content;
                        break;
                    case 'dialogue':
                        // Parse dialogue lines
                        const dialoguePattern = /([^:]+):\s*\(([^)]+)\)\s*"([^"]+)"/g;
                        let match;
                        while ((match = dialoguePattern.exec(content)) !== null) {
                            scene.dialogue.push({
                                speaker: match[1].trim(),
                                tone: match[2].trim(),
                                text: match[3].trim()
                            });
                        }
                        break;
                    case 'options':
                        // Parse numbered options
                        const lines = content.split('\n');
                        lines.forEach(line => {
                            const optionMatch = line.match(/^\d+\.\s*(.+)$/);
                            if (optionMatch) {
                                scene.options.push(optionMatch[1].trim());
                            }
                        });
                        break;
                    case 'hook':
                        scene.hook = content;
                        break;
                }
            }
        }
        
        // Ensure we have 4 options
        while (scene.options.length < 4) {
            scene.options.push(`Option ${scene.options.length + 1}`);
        }
        scene.options = scene.options.slice(0, 4);
        
        return scene;
    }
    
    displayScene(scene) {
        const content = document.getElementById('content-container');
        
        let html = '<div class="narrative-container">';
        
        // Setting section
        if (scene.setting) {
            html += `
                <div class="narrative-section">
                    <div class="environment-section">
                        ${this.formatParagraphs(scene.setting)}
                    </div>
                </div>
            `;
        }
        
        // Action section
        if (scene.action) {
            html += `
                <div class="narrative-section">
                    <div class="scene-text">
                        ${this.formatParagraphs(scene.action)}
                    </div>
                </div>
            `;
        }
        
        // Characters section
        if (scene.characters) {
            html += `
                <div class="narrative-section">
                    <div class="scene-text">
                        ${this.formatParagraphs(scene.characters)}
                    </div>
                </div>
            `;
        }
        
        // Dialogue section
        if (scene.dialogue && scene.dialogue.length > 0) {
            html += '<div class="dialogue-container">';
            scene.dialogue.forEach(line => {
                html += `
                    <div class="dialogue-line">
                        <div class="speaker-name">${line.speaker}</div>
                        <div class="speaker-tone">${line.tone}</div>
                        <div class="dialogue-text">${line.text}</div>
                    </div>
                `;
            });
            html += '</div>';
        }
        
        // Hook section
        if (scene.hook) {
            html += `
                <div class="narrative-section">
                    <div class="scene-text" style="text-align: center; font-style: italic;">
                        ${this.formatParagraphs(scene.hook)}
                    </div>
                </div>
            `;
        }
        
        html += '</div>';
        
        // Options
        html += '<div class="choices-container">';
        scene.options.forEach((option, i) => {
            html += `
                <div class="choice-card" onclick="app.handleChoice(${i + 1})">
                    <span class="choice-number">${i + 1}</span>
                    <span class="choice-text">${option}</span>
                </div>
            `;
        });
        html += '</div>';
        
        // Custom action
        html += `
            <div class="custom-action-container">
                <div class="custom-action-label">Create Your Own Action</div>
                <form class="custom-action-form" onsubmit="event.preventDefault(); app.submitCustomAction();">
                    <input type="text" 
                           id="custom-action-input" 
                           class="custom-input" 
                           placeholder="Describe what you want to do..."
                           autocomplete="off">
                    <button type="submit" class="action-button">Go</button>
                </form>
                <button class="regenerate-button" onclick="app.regenerateScene()">
                    <span class="regenerate-icon">↻</span>
                    Regenerate Scene
                </button>
            </div>
        `;
        
        content.innerHTML = html;
        
        // Focus custom input
        setTimeout(() => {
            document.getElementById('custom-action-input')?.focus();
        }, 100);
        
        // Smooth scroll to top
        window.scrollTo({ top: 0, behavior: 'smooth' });
        
        this.updateSceneCounter();
    }
    
    formatParagraphs(text) {
        return text.split('\n\n')
            .map(para => para.trim())
            .filter(para => para)
            .map(para => `<p>${para}</p>`)
            .join('');
    }
    
    submitCustomAction() {
        const input = document.getElementById('custom-action-input');
        const action = input.value.trim();
        if (action) {
            this.handleCustomAction(action);
        }
    }
    
    // ============================================
    // CONTEXT & MEMORY MANAGEMENT
    // ============================================
    
    saveScene(scene) {
        // Update story
        this.currentStory.sceneCount++;
        this.currentStory.lastSceneTime = Date.now();
        this.saveToStorage(this.STORAGE_KEYS.CURRENT_STORY, this.currentStory);
        
        // Save to scene history
        let history = this.getFromStorage(this.STORAGE_KEYS.SCENE_HISTORY) || [];
        history.push({
            ...scene,
            sceneNumber: this.currentStory.sceneCount,
            timestamp: Date.now()
        });
        
        // Keep only last 50 scenes
        if (history.length > 50) {
            history = history.slice(-50);
        }
        
        this.saveToStorage(this.STORAGE_KEYS.SCENE_HISTORY, history);
        
        // Update world state
        this.updateWorldState(scene);
    }
    
    updateWorldState(scene) {
        const worldState = this.getFromStorage(this.STORAGE_KEYS.WORLD_STATE) || {
            characters: {},
            locations: {},
            items: {},
            facts: []
        };
        
        // Extract character names from dialogue
        if (scene.dialogue) {
            scene.dialogue.forEach(line => {
                if (!worldState.characters[line.speaker]) {
                    worldState.characters[line.speaker] = {
                        firstSeen: this.currentStory.sceneCount,
                        lastSeen: this.currentStory.sceneCount
                    };
                } else {
                    worldState.characters[line.speaker].lastSeen = this.currentStory.sceneCount;
                }
            });
        }
        
        this.saveToStorage(this.STORAGE_KEYS.WORLD_STATE, worldState);
    }
    
    getRecentScenes(count = 5) {
        const history = this.getFromStorage(this.STORAGE_KEYS.SCENE_HISTORY) || [];
        return history.slice(-count);
    }
    
    buildContextSummary(recentScenes) {
        if (!recentScenes || recentScenes.length === 0) {
            return 'This is the beginning of the story.';
        }
        
        const summaries = recentScenes.map(scene => {
            let summary = `Scene ${scene.sceneNumber}: `;
            if (scene.hook) {
                summary += scene.hook;
            } else if (scene.action) {
                summary += scene.action.substring(0, 100) + '...';
            }
            return summary;
        });
        
        return summaries.join(' | ');
    }
    
    updateSceneCounter() {
        const counter = document.getElementById('scene-counter');
        if (counter && this.currentStory) {
            counter.textContent = `Scene ${this.currentStory.sceneCount}`;
        }
    }
    
    // ============================================
    // GPT API CALLS
    // ============================================
    
    async callGPT(messages, temperature = 0.8, maxTokens = 8000) {
        // Store context for regeneration
        this.lastContext = messages;
        
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${this.apiKey}`
            },
            body: JSON.stringify({
                model: 'gpt-4.1-mini',
                messages: messages,
                temperature: temperature,
                max_tokens: maxTokens,
                presence_penalty: 0.6,
                frequency_penalty: 0.3
            })
        });
        
        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error?.message || 'API request failed');
        }
        
        const data = await response.json();
        return data.choices[0].message.content;
    }
    
    // ============================================
    // UI UTILITIES
    // ============================================
    
    showLoading() {
        document.getElementById('loading-container').classList.remove('hidden');
        document.getElementById('app').classList.add('hidden');
    }
    
    hideLoading() {
        document.getElementById('loading-container').classList.add('hidden');
        document.getElementById('app').classList.remove('hidden');
    }
    
    showProcessing(message = 'Processing...') {
        const overlay = document.createElement('div');
        overlay.id = 'processing-overlay';
        overlay.className = 'processing-overlay';
        overlay.innerHTML = `
            <div class="processing-card">
                <div class="processing-spinner"></div>
                <div class="processing-text">${message}</div>
            </div>
        `;
        document.body.appendChild(overlay);
    }
    
    hideProcessing() {
        const overlay = document.getElementById('processing-overlay');
        if (overlay) overlay.remove();
    }
    
    showToast(message, type = 'info') {
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.textContent = message;
        document.body.appendChild(toast);
        
        setTimeout(() => {
            toast.style.animation = 'slideDown 0.3s reverse';
            setTimeout(() => toast.remove(), 300);
        }, 3000);
    }
    
    showError(message) {
        this.showToast(message, 'error');
    }
    
    showSuccess(message) {
        this.showToast(message, 'success');
    }
}

// ============================================
// INITIALIZE APP
// ============================================

let app = null;

document.addEventListener('DOMContentLoaded', () => {
    app = new InfinityEngine();
});

// Make app globally accessible
window.app = app;
    </script>
</body>
</html>