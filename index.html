<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <title>Infinity Engine RPG - PSP Anniversary Edition</title>
    
    <!-- PSP Anniversary Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Rajdhani:wght@400;500;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    
    <style>
        /* ================================
           PSP DARK MINIMAL THEME
           ================================ */
        :root {
            --psp-black: #000000;
            --psp-dark: #0a0a0a;
            --psp-gray-dark: #1a1a1a;
            --psp-gray: #2a2a2a;
            --psp-gray-light: #3a3a3a;
            --psp-text: #c0c0c0;
            --psp-text-bright: #ffffff;
            --psp-accent: #4a90e2;  /* Single blue accent */
            --psp-accent-dark: #357abd;
            --psp-border: rgba(255, 255, 255, 0.1);
            --controller-pattern: rgba(255, 255, 255, 0.01);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        /* Allow text selection only for inputs */
        input, textarea {
            -webkit-user-select: text;
            user-select: text;
        }

        body {
            background: var(--psp-black);
            color: var(--psp-text);
            font-family: 'Rajdhani', sans-serif;
            font-size: 16px;
            line-height: 1.6;
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* PSP Controller Pattern Background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                repeating-linear-gradient(45deg, transparent, transparent 35px, var(--controller-pattern) 35px, var(--controller-pattern) 70px),
                repeating-linear-gradient(-45deg, transparent, transparent 35px, var(--controller-pattern) 35px, var(--controller-pattern) 70px);
            pointer-events: none;
            z-index: 1;
        }

        /* Main Container */
        #main-container {
            position: relative;
            z-index: 2;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* PSP Anniversary Header */
        .psp-header {
            background: var(--psp-gray-dark);
            padding: 1px 0;
            margin-bottom: 20px;
        }

        .psp-header-inner {
            background: var(--psp-black);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top: 1px solid var(--psp-border);
            border-bottom: 1px solid var(--psp-border);
        }

        .game-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 28px;
            letter-spacing: 2px;
            color: var(--psp-text);
        }

        .scene-counter {
            font-family: 'Share Tech Mono', monospace;
            font-size: 14px;
            color: var(--psp-accent);
        }

        /* Game Screen */
        #game-screen {
            flex: 1;
            padding: 0 20px 120px;
            max-width: 800px;
            margin: 0 auto;
            width: 100%;
        }

        /* Loading Screen */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--psp-pure-black);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .loading-logo {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 60px;
            color: var(--psp-text);
            margin-bottom: 30px;
            letter-spacing: 3px;
        }

        .loading-bar {
            width: 200px;
            height: 2px;
            background: var(--psp-gray);
            overflow: hidden;
        }

        .loading-fill {
            height: 100%;
            background: var(--psp-accent);
            animation: loading 2s ease-in-out infinite;
        }

        @keyframes loading {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* Narrative Display Box */
        .narrative-box {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid var(--psp-border);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            position: relative;
            backdrop-filter: blur(10px);
        }

        /* Environmental Description */
        .environment-description {
            font-style: italic;
            color: var(--psp-text);
            margin-bottom: 15px;
            font-size: 18px;
            line-height: 1.5;
            padding-left: 15px;
            border-left: 2px solid var(--psp-accent);
        }

        /* Character Positions */
        .character-positions {
            background: rgba(255, 255, 255, 0.02);
            border-left: 3px solid var(--psp-gray-light);
            padding: 10px 15px;
            margin-bottom: 15px;
        }

        .position-entry {
            margin: 5px 0;
            font-weight: 500;
        }

        .position-character {
            color: var(--psp-accent);
            font-weight: 700;
        }

        /* Dialogue Section */
        .dialogue-section {
            margin: 20px 0;
        }

        .dialogue-line {
            margin: 15px 0;
            padding-left: 20px;
            position: relative;
        }

        .dialogue-line::before {
            content: '▸';
            position: absolute;
            left: 0;
            color: var(--psp-gray-light);
        }

        .character-name {
            color: var(--psp-accent);
            font-weight: 700;
            text-transform: uppercase;
            font-size: 14px;
        }

        .character-tone {
            color: var(--psp-gray-light);
            font-size: 12px;
            font-style: italic;
        }

        .dialogue-text {
            display: block;
            margin-top: 5px;
            color: var(--psp-text);
            font-size: 17px;
        }

        /* Scene Hook */
        .scene-hook {
            background: linear-gradient(180deg, transparent, rgba(255, 255, 255, 0.02));
            border-top: 1px solid var(--psp-border);
            margin-top: 20px;
            padding: 15px;
            text-align: center;
            font-style: italic;
            color: var(--psp-text);
            font-size: 18px;
        }

        /* PSP Button Choices */
        .choice-container {
            margin: 25px 0;
        }

        .choice-wrapper {
            position: relative;
            margin: 15px 0;
        }

        .choice-button {
            display: block;
            width: 100%;
            padding: 18px 60px 18px 20px;
            background: var(--psp-gray);
            border: none;
            border-radius: 8px;
            color: var(--psp-white);
            font-family: 'Rajdhani', sans-serif;
            font-size: 17px;
            font-weight: 500;
            text-align: left;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }

        .choice-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }

        .choice-button:hover::before {
            left: 100%;
        }

        .choice-button:hover {
            transform: translateX(5px);
            background: var(--psp-light-gray);
        }

        /* PSP Button Icons */
        .psp-button-icon {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
            background: var(--psp-gray-light);
            color: var(--psp-text);
            border: 1px solid var(--psp-border);
        }

        .choice-wrapper:nth-child(1) .psp-button-icon { background: var(--psp-accent); color: white; }
        .choice-wrapper:nth-child(2) .psp-button-icon { background: var(--psp-gray-light); }
        .choice-wrapper:nth-child(3) .psp-button-icon { background: var(--psp-gray); }
        .choice-wrapper:nth-child(4) .psp-button-icon { background: var(--psp-gray-dark); }

        /* Custom Action Section */
        .custom-action-section {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid var(--psp-border);
            border-radius: 8px;
            padding: 20px;
            margin: 30px 0;
        }

        .custom-action-label {
            color: var(--psp-text);
            font-weight: 700;
            text-transform: uppercase;
            margin-bottom: 10px;
            font-size: 14px;
            letter-spacing: 1px;
        }

        .custom-action-wrapper {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .custom-action-input {
            flex: 1;
            padding: 12px 15px;
            background: var(--psp-black);
            border: 1px solid var(--psp-gray-light);
            border-radius: 6px;
            color: var(--psp-text-bright);
            font-family: 'Rajdhani', sans-serif;
            font-size: 16px;
            transition: border-color 0.2s;
        }

        .custom-action-input:focus {
            outline: none;
            border-color: var(--psp-accent);
        }

        .custom-action-input::placeholder {
            color: var(--psp-gray-light);
            font-style: italic;
        }

        .submit-button {
            padding: 12px 24px;
            background: var(--psp-accent);
            border: none;
            border-radius: 6px;
            color: var(--psp-text-bright);
            font-weight: 700;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }

        .submit-button:hover {
            background: var(--psp-accent-dark);
            transform: translateY(-1px);
        }

        /* Regenerate Button */
        .regenerate-button {
            width: 100%;
            padding: 12px;
            background: var(--psp-gray);
            border: 1px solid var(--psp-gray-light);
            border-radius: 6px;
            color: var(--psp-text);
            font-weight: 700;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .regenerate-button:hover {
            background: var(--psp-gray-light);
            border-color: var(--psp-accent);
        }

        .regenerate-button::before {
            content: '↻';
            font-size: 18px;
        }

        /* Character Creation */
        .creation-screen {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }

        .creation-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 36px;
            text-align: center;
            margin-bottom: 30px;
            color: var(--psp-text);
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        .creation-input {
            width: 100%;
            padding: 15px;
            background: var(--psp-black);
            border: 1px solid var(--psp-gray-light);
            border-radius: 8px;
            color: var(--psp-text-bright);
            font-family: 'Rajdhani', sans-serif;
            font-size: 18px;
            margin-bottom: 20px;
            transition: border-color 0.2s;
        }

        .creation-input:focus {
            outline: none;
            border-color: var(--psp-accent);
        }

        /* Dynamic Class Selection */
        .class-grid {
            display: grid;
            gap: 15px;
            margin-bottom: 20px;
        }

        .class-option {
            background: var(--psp-gray);
            border: 2px solid transparent;
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .class-option:hover {
            border-color: var(--psp-yellow);
            transform: translateY(-2px);
        }

        .class-option.selected {
            border-color: var(--psp-green);
            background: rgba(0, 255, 0, 0.1);
        }

        .class-name {
            font-weight: 700;
            color: var(--psp-yellow);
            font-size: 18px;
            margin-bottom: 5px;
        }

        .class-description {
            color: var(--psp-light-gray);
            font-size: 14px;
            line-height: 1.4;
        }

        /* Messages */
        .message {
            padding: 15px 20px;
            border-radius: 6px;
            margin: 15px 0;
            font-weight: 500;
            animation: slideIn 0.3s ease-out;
            border: 1px solid;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.error {
            background: rgba(255, 255, 255, 0.05);
            border-color: var(--psp-gray-light);
            color: var(--psp-text);
        }

        .message.success {
            background: rgba(74, 144, 226, 0.1);
            border-color: var(--psp-accent);
            color: var(--psp-accent);
        }

        .message.info {
            background: rgba(255, 255, 255, 0.05);
            border-color: var(--psp-gray-light);
            color: var(--psp-text);
        }

        /* Processing Overlay */
        .processing-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9998;
        }

        .processing-content {
            text-align: center;
        }

        .processing-spinner {
            width: 60px;
            height: 60px;
            border: 2px solid var(--psp-gray);
            border-top: 2px solid var(--psp-accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Mobile Optimizations */
        @media (max-width: 600px) {
            .game-title { font-size: 24px; }
            .loading-logo { font-size: 48px; }
            .creation-title { font-size: 30px; }
            #game-screen { padding: 0 15px 100px; }
            .narrative-box { padding: 15px; }
        }

        /* Hide scrollbar but keep functionality */
        * {
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        
        *::-webkit-scrollbar {
            display: none;
        }

        /* Ensure elements aren't hidden */
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading-screen">
        <div class="loading-logo">INFINITY</div>
        <div class="loading-bar">
            <div class="loading-fill"></div>
        </div>
    </div>

    <!-- Main Container -->
    <div id="main-container" class="hidden">
        <!-- PSP Anniversary Header -->
        <div class="psp-header">
            <div class="psp-header-inner">
                <div class="game-title">INFINITY ENGINE</div>
                <div class="scene-counter">SCENE <span id="scene-count">1</span></div>
            </div>
        </div>

        <!-- Game Screen -->
        <div id="game-screen">
            <!-- Dynamic content will be inserted here -->
        </div>
    </div>

    <script>
// ============================================
// INFINITY ENGINE RPG - PSP ANNIVERSARY EDITION
// ============================================

// Global app instance
let app = null;

// ============================================
// MEMORY PALACE - Persistent Storage System
// ============================================
class MemoryPalace {
    constructor() {
        this.storageAvailable = false;
        this.currentStory = null;
        this.memoryPrefix = 'infinity_';
        this.lastContext = null;
    }

    async initialize() {
        // Check storage availability
        try {
            const test = 'test';
            localStorage.setItem(test, test);
            localStorage.removeItem(test);
            this.storageAvailable = true;
            console.log('Memory Palace: localStorage available');
        } catch (e) {
            console.log('Memory Palace: Using session memory');
            this.storageAvailable = false;
            this.memoryStore = {};
        }
    }

    setItem(key, value) {
        const fullKey = this.memoryPrefix + key;
        if (this.storageAvailable) {
            localStorage.setItem(fullKey, JSON.stringify(value));
        } else {
            if (!this.memoryStore) this.memoryStore = {};
            this.memoryStore[fullKey] = value;
        }
    }

    getItem(key) {
        const fullKey = this.memoryPrefix + key;
        if (this.storageAvailable) {
            const item = localStorage.getItem(fullKey);
            return item ? JSON.parse(item) : null;
        } else {
            return this.memoryStore?.[fullKey] || null;
        }
    }

    async createNewStory(characterData) {
        const story = {
            id: `story_${Date.now()}`,
            created: new Date().toISOString(),
            protagonist: characterData,
            sceneCount: 0,
            lastContext: null
        };
        
        this.currentStory = story;
        this.setItem('current_story', story);
        
        return story;
    }

    async saveScene(scene) {
        if (!this.currentStory) return;
        
        scene.id = `scene_${Date.now()}`;
        scene.storyId = this.currentStory.id;
        
        // Save scene
        const scenes = this.getItem('scenes') || [];
        scenes.push(scene);
        
        // Keep only last 50 scenes in storage
        if (scenes.length > 50) {
            scenes.shift();
        }
        
        this.setItem('scenes', scenes);
        
        // Update story
        this.currentStory.sceneCount++;
        this.currentStory.lastScene = scene;
        this.currentStory.lastContext = this.lastContext;
        this.setItem('current_story', this.currentStory);
    }

    async saveApiKey(apiKey) {
        this.setItem('api_key', apiKey);
    }

    async getApiKey() {
        return this.getItem('api_key');
    }

    async getCurrentStory() {
        if (this.currentStory) return this.currentStory;
        this.currentStory = this.getItem('current_story');
        return this.currentStory;
    }

    async getRecentScenes(count = 5) {
        if (!this.currentStory) return [];
        const scenes = this.getItem('scenes') || [];
        return scenes.slice(-count);
    }

    saveLastContext(context) {
        this.lastContext = context;
        if (this.currentStory) {
            this.currentStory.lastContext = context;
            this.setItem('current_story', this.currentStory);
        }
    }

    getLastContext() {
        return this.lastContext || this.currentStory?.lastContext || null;
    }
}

// ============================================
// NARRATIVE ENGINE - GPT Integration
// ============================================
class NarrativeEngine {
    constructor() {
        this.apiKey = null;
        this.apiUrl = 'https://api.openai.com/v1/chat/completions';
        this.lastMessages = null;
    }

    setApiKey(key) {
        this.apiKey = key;
    }

    async generateScene(context) {
        const messages = this.buildMessages(context);
        this.lastMessages = messages; // Save for regeneration
        
        try {
            const response = await fetch(this.apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.apiKey}`
                },
                body: JSON.stringify({
                    model: 'gpt-3.5-turbo',
                    messages: messages,
                    temperature: 0.8,
                    max_tokens: 1000
                })
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error?.message || 'API request failed');
            }

            const data = await response.json();
            return data.choices[0].message.content;
        } catch (error) {
            console.error('GPT error:', error);
            throw error;
        }
    }

    async regenerateScene() {
        if (!this.lastMessages) {
            throw new Error('No previous scene to regenerate');
        }
        
        try {
            const response = await fetch(this.apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.apiKey}`
                },
                body: JSON.stringify({
                    model: 'gpt-3.5-turbo',
                    messages: this.lastMessages,
                    temperature: 0.9, // Slightly higher for more variation
                    max_tokens: 1000
                })
            });

            if (!response.ok) {
                throw new Error('Regeneration failed');
            }

            const data = await response.json();
            return data.choices[0].message.content;
        } catch (error) {
            console.error('Regeneration error:', error);
            throw error;
        }
    }

    async generateClasses() {
        const messages = [
            {
                role: 'system',
                content: 'You are a fantasy RPG class generator. Generate exactly 6 unique and creative character classes with brief descriptions. Format as JSON array with "name" and "description" fields. Make them unique and interesting, not generic fantasy classes.'
            },
            {
                role: 'user',
                content: 'Generate 6 unique character classes for a narrative-focused fantasy RPG. Be creative and avoid standard classes like warrior or mage.'
            }
        ];

        try {
            const response = await fetch(this.apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.apiKey}`
                },
                body: JSON.stringify({
                    model: 'gpt-3.5-turbo',
                    messages: messages,
                    temperature: 0.9,
                    max_tokens: 500
                })
            });

            if (!response.ok) {
                throw new Error('Failed to generate classes');
            }

            const data = await response.json();
            const content = data.choices[0].message.content;
            
            // Try to parse JSON from response
            try {
                const jsonMatch = content.match(/\[[\s\S]*\]/);
                if (jsonMatch) {
                    return JSON.parse(jsonMatch[0]);
                }
            } catch (e) {
                console.error('Failed to parse classes JSON');
            }
            
            // Fallback classes if generation fails
            return this.getFallbackClasses();
        } catch (error) {
            console.error('Class generation error:', error);
            return this.getFallbackClasses();
        }
    }

    getFallbackClasses() {
        return [
            { name: "Voidweaver", description: "Manipulates the space between realities" },
            { name: "Chronothief", description: "Steals moments from the flow of time" },
            { name: "Soulwright", description: "Forges destinies from raw spirit essence" },
            { name: "Gloomcaster", description: "Commands shadows and forgotten sorrows" },
            { name: "Starwhisper", description: "Speaks the ancient language of cosmos" },
            { name: "Thornheart", description: "Channels nature's beautiful cruelty" }
        ];
    }

    buildMessages(context) {
        const messages = [
            {
                role: 'system',
                content: `You are a collaborative fantasy narrative engine. Create rich, immersive scenes following this EXACT format:

[Environmental Description]
2-3 sentences of vivid sensory details. Include magical atmosphere, sounds, smells, and visual elements.

[Character Positions]
List each character present and describe where they are and what they're doing.

[Dialogue]
Format EXACTLY as: CharacterName: (emotion/tone) "What they say."
Make dialogue natural and character-appropriate.

[Choices]
Present exactly 4 choices:
1. [Action Type]: Specific action description
2. [Action Type]: Different approach  
3. [Action Type]: Creative/unexpected option
4. [Action Type]: Character-specific option based on their class/personality

[Scene Hook]
1-2 sentences that create tension or anticipation for what comes next.

Current protagonist: ${context.protagonist?.name || 'Unknown'} the ${context.protagonist?.class || 'Unknown'}
${context.recentEvents ? `Recent events: ${context.recentEvents}` : ''}
${context.customContext || ''}`
            }
        ];

        if (context.previousSummary) {
            messages.push({
                role: 'assistant',
                content: context.previousSummary
            });
        }

        messages.push({
            role: 'user',
            content: context.userInput
        });

        return messages;
    }
}

// ============================================
// UI MANAGER - Interface Controller
// ============================================
class UIManager {
    constructor() {
        this.gameScreen = null;
        this.sceneCounter = null;
        this.processingOverlay = null;
    }

    initialize() {
        this.gameScreen = document.getElementById('game-screen');
        this.sceneCounter = document.getElementById('scene-count');
    }

    hideLoading() {
        setTimeout(() => {
            document.getElementById('loading-screen').style.display = 'none';
            document.getElementById('main-container').classList.remove('hidden');
        }, 1500);
    }

    showError(message) {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'message error';
        errorDiv.textContent = message;
        this.gameScreen.insertBefore(errorDiv, this.gameScreen.firstChild);
        setTimeout(() => errorDiv.remove(), 5000);
    }

    showInfo(message) {
        const infoDiv = document.createElement('div');
        infoDiv.className = 'message info';
        infoDiv.textContent = message;
        this.gameScreen.insertBefore(infoDiv, this.gameScreen.firstChild);
        setTimeout(() => infoDiv.remove(), 5000);
    }

    showProcessing(message = 'Weaving narrative threads...') {
        this.processingOverlay = document.createElement('div');
        this.processingOverlay.className = 'processing-overlay';
        this.processingOverlay.innerHTML = `
            <div class="processing-content">
                <div class="processing-spinner"></div>
                <div style="color: #ffcc00; font-size: 18px;">${message}</div>
            </div>
        `;
        document.body.appendChild(this.processingOverlay);
    }

    hideProcessing() {
        if (this.processingOverlay) {
            this.processingOverlay.remove();
            this.processingOverlay = null;
        }
    }

    async showApiKeyPrompt() {
        this.gameScreen.innerHTML = `
            <div class="creation-screen">
                <h1 class="creation-title">INITIALIZE NARRATIVE ENGINE</h1>
                <div class="narrative-box" style="margin-bottom: 30px;">
                    <p style="margin-bottom: 20px;">Enter your OpenAI API key to power the infinite narrative engine.</p>
                    <p style="color: #666; font-size: 14px;">Your key is stored locally and never sent anywhere except OpenAI.</p>
                </div>
                <input type="password" 
                       id="api-key-input" 
                       class="creation-input" 
                       placeholder="sk-..."
                       autocomplete="off">
                <button class="submit-button" style="width: 100%; font-size: 18px;" onclick="app.submitApiKey()">
                    ACTIVATE ENGINE
                </button>
                <p style="margin-top: 20px; text-align: center;">
                    <a href="https://platform.openai.com/api-keys" 
                       target="_blank" 
                       style="color: #00ff00; text-decoration: none;">
                        Get your API key from OpenAI →
                    </a>
                </p>
            </div>
        `;
        
        // Focus input
        setTimeout(() => {
            document.getElementById('api-key-input')?.focus();
        }, 100);
    }

    async showCharacterCreation() {
        const character = {};
        
        // Name step
        await this.showNameStep(character);
        // Class step with dynamic generation
        await this.showClassStep(character);
        
        return character;
    }

    showNameStep(character) {
        return new Promise((resolve) => {
            this.gameScreen.innerHTML = `
                <div class="creation-screen">
                    <h1 class="creation-title">FORGE YOUR IDENTITY</h1>
                    <div class="narrative-box">
                        <p>Before the infinite narrative begins, you must have a name...</p>
                    </div>
                    <input type="text" 
                           id="character-name" 
                           class="creation-input" 
                           placeholder="Enter your name..."
                           maxlength="30"
                           autocomplete="off">
                    <button class="submit-button" style="width: 100%; font-size: 18px;" id="continue-name">
                        CONTINUE →
                    </button>
                </div>
            `;
            
            const input = document.getElementById('character-name');
            const button = document.getElementById('continue-name');
            
            input.focus();
            
            const proceed = () => {
                const name = input.value.trim();
                if (name) {
                    character.name = name;
                    resolve();
                } else {
                    this.showError('A name is required to begin your journey');
                }
            };
            
            button.onclick = proceed;
            input.onkeypress = (e) => {
                if (e.key === 'Enter') proceed();
            };
        });
    }

    async showClassStep(character) {
        // Show loading while generating classes
        this.showProcessing('Discovering unique paths...');
        
        const classes = await app.narrativeEngine.generateClasses();
        
        this.hideProcessing();
        
        return new Promise((resolve) => {
            this.gameScreen.innerHTML = `
                <div class="creation-screen">
                    <h1 class="creation-title">CHOOSE YOUR PATH</h1>
                    <div class="narrative-box" style="margin-bottom: 20px;">
                        <p>Select the class that resonates with your soul...</p>
                    </div>
                    <div class="class-grid">
                        ${classes.map((cls, i) => `
                            <div class="class-option" data-class="${cls.name}" data-index="${i}">
                                <div class="class-name">${cls.name}</div>
                                <div class="class-description">${cls.description}</div>
                            </div>
                        `).join('')}
                    </div>
                    <button class="regenerate-button" onclick="app.regenerateClasses()">
                        SHOW DIFFERENT CLASSES
                    </button>
                </div>
            `;
            
            let selectedClass = null;
            
            document.querySelectorAll('.class-option').forEach(option => {
                option.onclick = () => {
                    document.querySelectorAll('.class-option').forEach(o => 
                        o.classList.remove('selected')
                    );
                    option.classList.add('selected');
                    selectedClass = {
                        name: option.dataset.class,
                        description: classes[option.dataset.index].description
                    };
                    
                    // Auto-proceed after selection
                    setTimeout(() => {
                        if (selectedClass) {
                            character.class = selectedClass.name;
                            character.classDescription = selectedClass.description;
                            character.personality = "determined and mysterious";
                            character.appearance = "A figure of purpose and power";
                            character.background = "Your past is shrouded in mystery";
                            resolve();
                        }
                    }, 500);
                };
            });
            
            // Store resolve function for regeneration
            window._classResolve = resolve;
            window._character = character;
        });
    }

    displayScene(scene) {
        const parsed = this.parseScene(scene);
        
        this.gameScreen.innerHTML = `
            <div class="narrative-box">
                ${this.formatEnvironment(parsed.environment)}
                ${this.formatPositions(parsed.positions)}
                ${this.formatDialogue(parsed.dialogue)}
                ${this.formatHook(parsed.hook)}
            </div>
            ${this.formatChoices(parsed.choices)}
            ${this.formatCustomAction()}
        `;
        
        // Update scene counter
        if (app.memoryPalace.currentStory) {
            this.sceneCounter.textContent = app.memoryPalace.currentStory.sceneCount + 1;
        }
        
        // Scroll to top
        window.scrollTo(0, 0);
    }

    parseScene(text) {
        const scene = {
            environment: '',
            positions: {},
            dialogue: [],
            choices: [],
            hook: ''
        };
        
        const sections = text.split(/\[([^\]]+)\]/);
        let currentSection = '';
        
        for (let i = 0; i < sections.length; i++) {
            const content = sections[i].trim();
            
            if (content.match(/Environmental Description/i)) {
                currentSection = 'environment';
            } else if (content.match(/Character Positions/i)) {
                currentSection = 'positions';
            } else if (content.match(/Dialogue/i)) {
                currentSection = 'dialogue';
            } else if (content.match(/Choices/i)) {
                currentSection = 'choices';
            } else if (content.match(/Scene.*Hook/i)) {
                currentSection = 'hook';
            } else if (currentSection && content) {
                switch (currentSection) {
                    case 'environment':
                        scene.environment = content;
                        break;
                    case 'positions':
                        content.split('\n').forEach(line => {
                            const colonIndex = line.indexOf(':');
                            if (colonIndex > 0) {
                                const char = line.substring(0, colonIndex).trim();
                                const pos = line.substring(colonIndex + 1).trim();
                                if (char && pos) {
                                    scene.positions[char] = pos;
                                }
                            }
                        });
                        break;
                    case 'dialogue':
                        const dialoguePattern = /([^:]+):\s*\(([^)]+)\)\s*"([^"]+)"/g;
                        let match;
                        while ((match = dialoguePattern.exec(content)) !== null) {
                            scene.dialogue.push({
                                character: match[1].trim(),
                                tone: match[2].trim(),
                                text: match[3].trim()
                            });
                        }
                        break;
                    case 'choices':
                        const choiceLines = content.split(/\d+\.\s*/);
                        choiceLines.forEach(choice => {
                            const trimmed = choice.trim();
                            if (trimmed && !trimmed.match(/^\d+$/)) {
                                scene.choices.push(trimmed);
                            }
                        });
                        break;
                    case 'hook':
                        scene.hook = content;
                        break;
                }
            }
        }
        
        // Ensure we have exactly 4 choices
        while (scene.choices.length < 4) {
            scene.choices.push(`Option ${scene.choices.length + 1}: Continue exploring`);
        }
        scene.choices = scene.choices.slice(0, 4);
        
        return scene;
    }

    formatEnvironment(text) {
        if (!text) return '';
        return `<div class="environment-description">${text}</div>`;
    }

    formatPositions(positions) {
        if (!positions || Object.keys(positions).length === 0) return '';
        
        const entries = Object.entries(positions).map(([char, pos]) => `
            <div class="position-entry">
                <span class="position-character">${char}:</span> ${pos}
            </div>
        `).join('');
        
        return `<div class="character-positions">${entries}</div>`;
    }

    formatDialogue(dialogue) {
        if (!dialogue || dialogue.length === 0) return '';
        
        const lines = dialogue.map(line => `
            <div class="dialogue-line">
                <span class="character-name">${line.character}</span>
                <span class="character-tone">(${line.tone})</span>
                <span class="dialogue-text">${line.text}</span>
            </div>
        `).join('');
        
        return `<div class="dialogue-section">${lines}</div>`;
    }

    formatChoices(choices) {
        if (!choices || choices.length === 0) return '';
        
        const buttonIcons = ['X', '○', '□', '△'];
        const iconClasses = ['psp-x', 'psp-circle', 'psp-square', 'psp-triangle'];
        
        const buttons = choices.map((choice, i) => `
            <div class="choice-wrapper">
                <button class="choice-button" onclick="app.handleChoice(${i + 1})">
                    ${choice}
                    <span class="psp-button-icon ${iconClasses[i]}">${buttonIcons[i]}</span>
                </button>
            </div>
        `).join('');
        
        return `<div class="choice-container">${buttons}</div>`;
    }

    formatHook(text) {
        if (!text) return '';
        return `<div class="scene-hook">${text}</div>`;
    }

    formatCustomAction() {
        return `
            <div class="custom-action-section">
                <div class="custom-action-label">Forge Your Own Path</div>
                <div class="custom-action-wrapper">
                    <input type="text" 
                           id="custom-action-input" 
                           class="custom-action-input" 
                           placeholder="Describe what you want to do..."
                           autocomplete="off">
                    <button class="submit-button" onclick="app.handleCustomAction()">
                        GO
                    </button>
                </div>
                <button class="regenerate-button" onclick="app.regenerateScene()">
                    REGENERATE CURRENT SCENE
                </button>
            </div>
        `;
    }
}

// ============================================
// MAIN APPLICATION
// ============================================
class InfinityEngineApp {
    constructor() {
        this.memoryPalace = new MemoryPalace();
        this.narrativeEngine = new NarrativeEngine();
        this.ui = new UIManager();
        this.currentScene = null;
        this.isProcessing = false;
    }

    async initialize() {
        try {
            await this.memoryPalace.initialize();
            this.ui.initialize();
            
            // Check if running from file://
            if (window.location.protocol === 'file:') {
                this.ui.hideLoading();
                this.showSetupError();
                return;
            }
            
            // Check for API key
            const apiKey = await this.memoryPalace.getApiKey();
            if (!apiKey) {
                this.ui.hideLoading();
                await this.ui.showApiKeyPrompt();
                return;
            }
            
            this.narrativeEngine.setApiKey(apiKey);
            
            // Check for existing story
            const story = await this.memoryPalace.getCurrentStory();
            if (story) {
                await this.resumeStory();
            } else {
                await this.startNewStory();
            }
            
            this.ui.hideLoading();
            
        } catch (error) {
            console.error('Initialization error:', error);
            this.ui.hideLoading();
            this.ui.showError('Failed to initialize. Please refresh.');
        }
    }

    showSetupError() {
        this.ui.gameScreen.innerHTML = `
            <div class="narrative-box" style="text-align: center; margin-top: 50px;">
                <h2 style="color: #ff0033; margin-bottom: 20px;">⚠️ SETUP REQUIRED</h2>
                <p style="margin-bottom: 20px;">This game must be hosted online to work properly!</p>
                
                <div style="background: rgba(0,255,0,0.1); padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <h3 style="color: #00ff00;">Quick Fix (30 seconds):</h3>
                    <ol style="text-align: left; max-width: 400px; margin: 10px auto;">
                        <li>Save this file as "index.html"</li>
                        <li>Go to <a href="https://app.netlify.com/drop" target="_blank" style="color: #00ff00;">netlify.com/drop</a></li>
                        <li>Drag the file onto the page</li>
                        <li>Use the URL they give you!</li>
                    </ol>
                </div>
                
                <p style="color: #666; font-size: 14px;">
                    The game needs to save your progress, which browsers block for local files.
                </p>
            </div>
        `;
    }

    async submitApiKey() {
        const input = document.getElementById('api-key-input');
        const apiKey = input.value.trim();
        
        if (!apiKey || !apiKey.startsWith('sk-')) {
            this.ui.showError('Please enter a valid OpenAI API key');
            return;
        }
        
        await this.memoryPalace.saveApiKey(apiKey);
        this.narrativeEngine.setApiKey(apiKey);
        await this.startNewStory();
    }

    async startNewStory() {
        const character = await this.ui.showCharacterCreation();
        await this.memoryPalace.createNewStory(character);
        
        // Generate opening scene
        const context = {
            protagonist: character,
            userInput: `Begin an epic narrative. ${character.name} the ${character.class} arrives at a mysterious location. Create an atmospheric opening with an intriguing character and meaningful choices that reflect the ${character.class} class abilities.`
        };
        
        this.ui.showProcessing('Initializing your infinite narrative...');
        
        try {
            const scene = await this.narrativeEngine.generateScene(context);
            await this.displayAndSaveScene(scene);
        } catch (error) {
            this.ui.showError(`Failed to start narrative: ${error.message}`);
        }
        
        this.ui.hideProcessing();
    }

    async resumeStory() {
        const story = await this.memoryPalace.getCurrentStory();
        
        if (story.lastScene) {
            this.ui.displayScene(story.lastScene.text);
            this.currentScene = this.ui.parseScene(story.lastScene.text);
        } else {
            await this.generateContinuation();
        }
    }

    async handleChoice(choiceNum) {
        if (this.isProcessing || !this.currentScene) return;
        
        const choice = this.currentScene.choices[choiceNum - 1];
        if (!choice) return;
        
        this.isProcessing = true;
        this.ui.showProcessing();
        
        // Build context with memory
        const recentScenes = await this.memoryPalace.getRecentScenes(3);
        const previousSummary = recentScenes.map(s => 
            `[Previous scene]: ${s.parsed?.hook || 'Scene occurred'}`
        ).join('\n');
        
        const context = {
            protagonist: this.memoryPalace.currentStory.protagonist,
            recentEvents: `The ${this.memoryPalace.currentStory.protagonist.name} chose: "${choice}"`,
            previousSummary: previousSummary,
            userInput: `Continue the narrative based on this choice: "${choice}". Remember to incorporate the character's ${this.memoryPalace.currentStory.protagonist.class} abilities.`
        };
        
        try {
            const scene = await this.narrativeEngine.generateScene(context);
            await this.displayAndSaveScene(scene);
        } catch (error) {
            this.ui.showError('Failed to continue narrative. Check your connection.');
        }
        
        this.isProcessing = false;
        this.ui.hideProcessing();
    }

    async handleCustomAction() {
        const input = document.getElementById('custom-action-input');
        const action = input.value.trim();
        
        if (!action || this.isProcessing) return;
        
        this.isProcessing = true;
        this.ui.showProcessing();
        
        // Build context
        const recentScenes = await this.memoryPalace.getRecentScenes(3);
        const previousSummary = recentScenes.map(s => 
            `[Previous]: ${s.parsed?.hook || 'Scene occurred'}`
        ).join('\n');
        
        const context = {
            protagonist: this.memoryPalace.currentStory.protagonist,
            recentEvents: `Custom action attempted`,
            previousSummary: previousSummary,
            userInput: `The ${this.memoryPalace.currentStory.protagonist.name} attempts to: "${action}". Show the results of this action, considering their ${this.memoryPalace.currentStory.protagonist.class} abilities.`
        };
        
        try {
            const scene = await this.narrativeEngine.generateScene(context);
            await this.displayAndSaveScene(scene);
            input.value = ''; // Clear input
        } catch (error) {
            this.ui.showError('Failed to process action. Try again.');
        }
        
        this.isProcessing = false;
        this.ui.hideProcessing();
    }

    async regenerateScene() {
        if (this.isProcessing) return;
        
        this.isProcessing = true;
        this.ui.showProcessing('Reweaving the narrative threads...');
        
        try {
            const scene = await this.narrativeEngine.regenerateScene();
            
            // Don't save regenerated scenes to avoid duplicates
            const parsed = this.ui.parseScene(scene);
            this.currentScene = parsed;
            this.ui.displayScene(scene);
            
            this.ui.showInfo('Scene regenerated with new possibilities!');
        } catch (error) {
            this.ui.showError('Failed to regenerate scene. Try a custom action instead.');
        }
        
        this.isProcessing = false;
        this.ui.hideProcessing();
    }

    async regenerateClasses() {
        this.ui.showProcessing('Discovering new paths...');
        
        const classes = await this.narrativeEngine.generateClasses();
        
        this.ui.hideProcessing();
        
        // Update the class display
        const classGrid = document.querySelector('.class-grid');
        if (classGrid) {
            classGrid.innerHTML = classes.map((cls, i) => `
                <div class="class-option" data-class="${cls.name}" data-index="${i}">
                    <div class="class-name">${cls.name}</div>
                    <div class="class-description">${cls.description}</div>
                </div>
            `).join('');
            
            // Rebind click handlers
            document.querySelectorAll('.class-option').forEach(option => {
                option.onclick = () => {
                    document.querySelectorAll('.class-option').forEach(o => 
                        o.classList.remove('selected')
                    );
                    option.classList.add('selected');
                    
                    const selectedClass = {
                        name: option.dataset.class,
                        description: classes[option.dataset.index].description
                    };
                    
                    // Auto-proceed after selection
                    setTimeout(() => {
                        if (window._character && window._classResolve) {
                            window._character.class = selectedClass.name;
                            window._character.classDescription = selectedClass.description;
                            window._character.personality = "determined and mysterious";
                            window._character.appearance = "A figure of purpose and power";
                            window._character.background = "Your past is shrouded in mystery";
                            window._classResolve();
                        }
                    }, 500);
                };
            });
        }
    }

    async displayAndSaveScene(sceneText) {
        const parsed = this.ui.parseScene(sceneText);
        this.currentScene = parsed;
        
        // Save context for future use
        const context = {
            protagonist: this.memoryPalace.currentStory.protagonist,
            lastScene: parsed,
            timestamp: Date.now()
        };
        this.memoryPalace.saveLastContext(context);
        
        await this.memoryPalace.saveScene({
            text: sceneText,
            parsed: parsed,
            timestamp: Date.now()
        });
        
        this.ui.displayScene(sceneText);
    }

    async generateContinuation() {
        const context = {
            protagonist: this.memoryPalace.currentStory.protagonist,
            userInput: "Continue the epic narrative from where we left off."
        };
        
        this.ui.showProcessing('Resuming your infinite story...');
        
        try {
            const scene = await this.narrativeEngine.generateScene(context);
            await this.displayAndSaveScene(scene);
        } catch (error) {
            this.ui.showError('Failed to continue story. Check your API key.');
        }
        
        this.ui.hideProcessing();
    }
}

// ============================================
// INITIALIZE ON LOAD
// ============================================
document.addEventListener('DOMContentLoaded', async () => {
    app = new InfinityEngineApp();
    await app.initialize();
});

// Make app globally accessible
window.app = app;
    </script>
</body>
</html>